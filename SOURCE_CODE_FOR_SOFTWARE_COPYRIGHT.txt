================================================================================
è½¯ä»¶è‘—ä½œæƒç”³è¯· - æºç¨‹åºä»£ç 
================================================================================
é¡¹ç›®åç§°: ä¸ªäººç½‘å€å¯¼èˆªç³»ç»Ÿ
æäº¤æ—¶é—´: 2025å¹´12æœˆ16æ—¥
æ€»è¡Œæ•°: 34,569è¡Œ
æ€»é¡µæ•°: 692é¡µ (æŒ‰50è¡Œ/é¡µè®¡ç®—)
è¯´æ˜: ä»¥ä¸‹ä¸ºæºç¨‹åºçš„å‰30é¡µ(ç¬¬1-30é¡µ) + å30é¡µ(ç¬¬663-692é¡µ)

================================================================================
ç¬¬ 1-30 é¡µ (å‰ 30 é¡µ)
================================================================================
=== /Users/8086k/project/components/app/api/auth/email/route.ts ===
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'
import bcrypt from 'bcryptjs'
import cloudbase from '@cloudbase/node-sdk'

// æœåŠ¡å™¨ç«¯Supabaseå®¢æˆ·ç«¯ï¼ˆæ— éœ€localStorageï¼‰
function createServerClient() {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
  const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!

  return createClient(supabaseUrl, supabaseAnonKey, {
    auth: {
      autoRefreshToken: false,
      persistSession: false,
      detectSessionInUrl: false
    }
  })
}

/**
 * é‚®ç®±ç™»å½•/æ³¨å†ŒAPI
 * æ ¹æ®ç¯å¢ƒå˜é‡é€‰æ‹©æ•°æ®åº“ï¼š
 * - NEXT_PUBLIC_DEPLOYMENT_REGION=china â†’ è…¾è®¯äº‘CloudBase
 * - NEXT_PUBLIC_DEPLOYMENT_REGION=overseas â†’ Supabase
 */

// ä»ç¯å¢ƒå˜é‡è¯»å–éƒ¨ç½²åŒºåŸŸï¼ˆé»˜è®¤ä¸ºå›½å†…ç‰ˆï¼‰
const DEPLOYMENT_REGION = process.env.NEXT_PUBLIC_DEPLOYMENT_REGION || 'china'
const IS_CHINA_DEPLOYMENT = DEPLOYMENT_REGION === 'china'

// å›½å†…éƒ¨ç½²è®¤è¯ï¼ˆä½¿ç”¨è…¾è®¯äº‘CloudBaseæ•°æ®åº“ï¼‰
async function cloudbaseEmailAuth(email: string, password: string, mode: 'login' | 'signup') {
  try {
    console.log('[å›½å†…éƒ¨ç½²] ä½¿ç”¨è…¾è®¯äº‘CloudBaseæ•°æ®åº“')

    // åˆå§‹åŒ–CloudBase
    const app = cloudbase.init({
      env: process.env.NEXT_PUBLIC_WECHAT_CLOUDBASE_ID!,
      secretId: process.env.CLOUDBASE_SECRET_ID!,
      secretKey: process.env.CLOUDBASE_SECRET_KEY!
    })

    const db = app.database()
    const usersCollection = db.collection('web_users')

    if (mode === 'signup') {
      // æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²å­˜åœ¨
      const existingUser = await usersCollection.where({ email }).get()
      if (existingUser.data && existingUser.data.length > 0) {
        return { error: 'è¯¥é‚®ç®±å·²è¢«æ³¨å†Œ' }
      }

      // åŠ å¯†å¯†ç 
      const hashedPassword = await bcrypt.hash(password, 10)

      // åˆ›å»ºæ–°ç”¨æˆ·
      const newUser = {
        email,
        password: hashedPassword,
        name: email.includes('@') ? email.split('@')[0] : email,
        pro: false,
        region: 'china',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      }

      const result = await usersCollection.add(newUser)

      return {
        user: {
          id: result.id,
          email,
          name: newUser.name,
          pro: false,
          region: 'china'
        }
      }
    } else {
      // ç™»å½•ï¼šæŸ¥æ‰¾ç”¨æˆ·
      const userResult = await usersCollection.where({ email }).get()

      if (!userResult.data || userResult.data.length === 0) {
        return { error: 'ç”¨æˆ·ä¸å­˜åœ¨æˆ–å¯†ç é”™è¯¯' }
      }

      const user = userResult.data[0]

      // éªŒè¯å¯†ç 
      const isPasswordValid = await bcrypt.compare(password, user.password)
      if (!isPasswordValid) {
        return { error: 'ç”¨æˆ·ä¸å­˜åœ¨æˆ–å¯†ç é”™è¯¯' }
      }

      return {
        user: {
          id: user._id,
          email: user.email,
          name: user.name,
          pro: user.pro || false,
          region: 'china'
        }
      }
    }
  } catch (error) {
    console.error('å›½å†…ç”¨æˆ·è®¤è¯é”™è¯¯:', error)
    return { error: 'è®¤è¯å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•' }
  }
}

// æµ·å¤–éƒ¨ç½²è®¤è¯ï¼ˆSupabaseï¼Œregionæ ‡è®°ä¸ºoverseasï¼‰
async function supabaseEmailAuth(email: string, password: string, mode: 'login' | 'signup') {
  try {
    console.log('[æµ·å¤–éƒ¨ç½²] ä½¿ç”¨Supabaseå­˜å‚¨ï¼Œregionæ ‡è®°ä¸ºoverseas')

    const supabase = createServerClient()

    if (mode === 'signup') {
      const { data, error } = await supabase.auth.signUp({
        email,
        password,
        options: {
          data: {
            region: 'overseas', // æ ‡è®°ä¸ºæµ·å¤–ç”¨æˆ·
            full_name: email.split('@')[0],
          }
        }
      })

      if (error) {
        console.error('æµ·å¤–ç”¨æˆ·æ³¨å†Œé”™è¯¯:', error)
        return { error: error.message }
      }

      if (!data.user) {
        return { error: 'Registration failed' }
      }

      return {
        user: {
          id: data.user.id,
          email: data.user.email || email,
          name: email.split('@')[0],
          pro: false,
          region: 'overseas'
        }
      }
    } else {
      const { data, error } = await supabase.auth.signInWithPassword({
        email,
        password,
      })

      if (error) {
        console.error('æµ·å¤–ç”¨æˆ·ç™»å½•é”™è¯¯:', error)
        return { error: error.message }
      }

      if (!data.user) {
        return { error: 'Login failed' }
      }

      return {
        user: {
          id: data.user.id,
          email: data.user.email || email,
          name: data.user.user_metadata?.full_name || email.split('@')[0],
          pro: data.user.user_metadata?.pro || false,
          region: data.user.user_metadata?.region || 'overseas'
        }
      }
    }
  } catch (error) {
    console.error('æµ·å¤–ç”¨æˆ·è®¤è¯é”™è¯¯:', error)
    return { error: 'Authentication failed' }
  }
}

export async function POST(request: NextRequest) {
  try {
    const { email, password, mode } = await request.json()

    if (!email || !password) {
      return NextResponse.json(
        { error: 'è¯·å¡«å†™å®Œæ•´ä¿¡æ¯' },
        { status: 400 }
      )
    }

    console.log(`ğŸ“ éƒ¨ç½²åŒºåŸŸ: ${DEPLOYMENT_REGION} â†’ ${IS_CHINA_DEPLOYMENT ? 'ğŸ‡¨ğŸ‡³ å›½å†…ç‰ˆ' : 'ğŸŒ æµ·å¤–ç‰ˆ'}`)

    // éªŒè¯å¯†ç é•¿åº¦
    if (password.length < 6) {
      return NextResponse.json(
        { error: 'å¯†ç è‡³å°‘6ä½' },
        { status: 400 }
      )
    }

    // æ ¹æ®ç¯å¢ƒå˜é‡é€‰æ‹©è®¤è¯æ–¹å¼
    let result
    if (IS_CHINA_DEPLOYMENT) {
      console.log('ğŸ” [å›½å†…ç‰ˆ] ä½¿ç”¨CloudBaseæ•°æ®åº“')
      result = await cloudbaseEmailAuth(email, password, mode as 'login' | 'signup')
    } else {
      console.log('ğŸ” [æµ·å¤–ç‰ˆ] ä½¿ç”¨Supabaseæ•°æ®åº“')
      result = await supabaseEmailAuth(email, password, mode as 'login' | 'signup')
    }

    if (result.error) {
      return NextResponse.json(
        { error: result.error },
        { status: 400 }
      )
    }

    return NextResponse.json({
      success: true,
      user: result.user,
      database: IS_CHINA_DEPLOYMENT ? 'cloudbase' : 'supabase',
      region: IS_CHINA_DEPLOYMENT ? 'china' : 'overseas'
    })

  } catch (error) {
    console.error('é‚®ç®±è®¤è¯APIé”™è¯¯:', error)
    return NextResponse.json(
      { error: 'æœåŠ¡å™¨é”™è¯¯' },
      { status: 500 }
    )
  }
}
=== /Users/8086k/project/components/app/api/auth/wechat/callback/route.ts ===
import { NextRequest, NextResponse } from 'next/server'
import cloudbase from '@cloudbase/node-sdk'
import * as jwt from 'jsonwebtoken'

/**
 * å¾®ä¿¡ç½‘é¡µæˆæƒå›è°ƒ
 * æ–‡æ¡£ï¼šhttps://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html
 */
export async function GET(req: NextRequest) {
  try {
    // æ£€æŸ¥å¾®ä¿¡ç™»å½•æ˜¯å¦å·²é…ç½®
    if (!process.env.WECHAT_APP_ID || !process.env.WECHAT_APP_SECRET) {
      console.log('âš ï¸ [WeChat] å¾®ä¿¡ç™»å½•æœªé…ç½®ï¼Œé‡å®šå‘åˆ°é¦–é¡µ')
      return NextResponse.redirect(
        `${process.env.NEXT_PUBLIC_SITE_URL}/?error=wechat_not_configured`
      )
    }
    const searchParams = req.nextUrl.searchParams
    const code = searchParams.get('code')
    const state = searchParams.get('state')

    if (!code) {
      return NextResponse.redirect(
        `${process.env.NEXT_PUBLIC_SITE_URL}/?error=wechat_auth_failed`
      )
    }

    // é€šè¿‡codeè·å–access_token
    const tokenResponse = await fetch(
      `https://api.weixin.qq.com/sns/oauth2/access_token?` +
      `appid=${process.env.WECHAT_APP_ID}&` +
      `secret=${process.env.WECHAT_APP_SECRET}&` +
      `code=${code}&` +
      `grant_type=authorization_code`
    )

    const tokenData = await tokenResponse.json()

    if (tokenData.errcode) {
      console.error('âŒ è·å–å¾®ä¿¡access_tokenå¤±è´¥:', tokenData)
      return NextResponse.redirect(
        `${process.env.NEXT_PUBLIC_SITE_URL}/?error=wechat_token_failed`
      )
    }

    const { access_token, openid, refresh_token } = tokenData

    // è·å–ç”¨æˆ·ä¿¡æ¯
    const userInfoResponse = await fetch(
      `https://api.weixin.qq.com/sns/userinfo?` +
      `access_token=${access_token}&` +
      `openid=${openid}&` +
      `lang=zh_CN`
    )

    const userInfo = await userInfoResponse.json()

    if (userInfo.errcode) {
      console.error('âŒ è·å–å¾®ä¿¡ç”¨æˆ·ä¿¡æ¯å¤±è´¥:', userInfo)
      return NextResponse.redirect(
        `${process.env.NEXT_PUBLIC_SITE_URL}/?error=wechat_userinfo_failed`
      )
    }

    console.log('âœ… å¾®ä¿¡ç”¨æˆ·ä¿¡æ¯:', userInfo)

    // åˆå§‹åŒ–CloudBaseï¼ˆæœåŠ¡ç«¯ï¼‰
    const app = cloudbase.init({
      env: process.env.NEXT_PUBLIC_WECHAT_CLOUDBASE_ID!,
      secretId: process.env.CLOUDBASE_SECRET_ID!,
      secretKey: process.env.CLOUDBASE_SECRET_KEY!
    })

    const db = app.database()

    // ä¿å­˜/æ›´æ–°ç”¨æˆ·ä¿¡æ¯åˆ°è…¾è®¯äº‘æ•°æ®åº“
    try {
      // æŸ¥è¯¢æ˜¯å¦å·²å­˜åœ¨
      const existingUser = await db
        .collection('web_users')
        .where({
          _openid: openid,
        })
        .get()

      const userData = {
        _openid: openid,
        nickname: userInfo.nickname,
        avatar: userInfo.headimgurl,
        province: userInfo.province,
        city: userInfo.city,
        country: userInfo.country,
        sex: userInfo.sex,
        name: userInfo.nickname, // æ˜¾ç¤ºåç§°ä½¿ç”¨å¾®ä¿¡æ˜µç§°
        pro: false,
        region: 'china',
        loginType: 'wechat', // æ ‡è®°ä¸ºå¾®ä¿¡ç™»å½•
        updated_at: new Date(),
      }

      let userId: string
      let isPro = false

      if (existingUser.data && existingUser.data.length > 0) {
        // æ›´æ–°ç°æœ‰ç”¨æˆ·
        userId = existingUser.data[0]._id
        isPro = existingUser.data[0].pro || false // ä¿ç•™åŸæœ‰ä¼šå‘˜çŠ¶æ€
        await db
          .collection('web_users')
          .doc(userId)
          .update(userData)

        console.log('âœ… æ›´æ–°å¾®ä¿¡ç”¨æˆ·æˆåŠŸ:', userId, isPro ? '(ä¼šå‘˜)' : '(æ™®é€šç”¨æˆ·)')
      } else {
        // åˆ›å»ºæ–°ç”¨æˆ·
        const result = await db
          .collection('web_users')
          .add({
            ...userData,
            created_at: new Date(),
          })

        userId = result.id
        console.log('âœ… åˆ›å»ºå¾®ä¿¡ç”¨æˆ·æˆåŠŸ:', userId)
      }

      // ç”Ÿæˆ JWT Token
      const tokenPayload = {
        userId: userId,
        openid: openid,
        nickname: userInfo.nickname,
        region: 'china',
        loginType: 'wechat'
      }

      // âœ… åŠ¨æ€è®¾ç½® Token æœ‰æ•ˆæœŸï¼šæ™®é€šç”¨æˆ· 30 å¤©ï¼Œé«˜çº§ä¼šå‘˜ 90 å¤©ï¼ˆå¤šç«¯æŒä¹…åŒ–ä¼˜åŒ–ï¼‰
      const expiresIn = isPro ? '90d' : '30d'

      const token = jwt.sign(
        tokenPayload,
        process.env.JWT_SECRET || 'fallback-secret-key-for-development-only',
        { expiresIn: expiresIn }
      )

      console.log('âœ… [JWT Token Generated]: For WeChat user', userInfo.nickname)

      // é‡å®šå‘å›é¦–é¡µï¼Œå¹¶ä¼ é€’ç™»å½•ä¿¡æ¯
      const redirectUrl = new URL(process.env.NEXT_PUBLIC_SITE_URL!)
      redirectUrl.searchParams.set('wechat_login', 'success')
      redirectUrl.searchParams.set('token', token)
      redirectUrl.searchParams.set('user', encodeURIComponent(JSON.stringify({
        id: userId,
        name: userInfo.nickname,
        avatar: userInfo.headimgurl,
        pro: false,
        region: 'china',
        loginType: 'wechat'
      })))

      return NextResponse.redirect(redirectUrl.toString())
    } catch (error) {
      console.error('âŒ ä¿å­˜å¾®ä¿¡ç”¨æˆ·ä¿¡æ¯å¤±è´¥:', error)
      return NextResponse.redirect(
        `${process.env.NEXT_PUBLIC_SITE_URL}/?error=save_user_failed`
      )
    }
  } catch (error: any) {
    console.error('âŒ å¾®ä¿¡ç™»å½•å›è°ƒå¤„ç†å¤±è´¥:', error)
    return NextResponse.redirect(
      `${process.env.NEXT_PUBLIC_SITE_URL}/?error=wechat_callback_failed`
    )
  }
}

/**
 * å‘èµ·å¾®ä¿¡ç½‘é¡µæˆæƒ
 * å‰ç«¯è°ƒç”¨æ­¤æ¥å£è·³è½¬åˆ°å¾®ä¿¡æˆæƒé¡µé¢
 */
export async function POST(req: NextRequest) {
  try {
    // âœ… å‰ç«¯ä¼ å…¥å®Œæ•´çš„ redirectUriï¼ˆä» window.location.origin è·å–ï¼‰
    const { redirectUri } = await req.json()

    const appid = process.env.WECHAT_APP_ID

    // ä½¿ç”¨å‰ç«¯ä¼ å…¥çš„ redirectUriï¼ˆå·²åŒ…å«å®Œæ•´åŸŸåï¼‰
    const callbackUrl = redirectUri || `http://localhost:3000/api/auth/wechat/callback`

    // ç¡®ä¿ç”Ÿäº§ç¯å¢ƒä½¿ç”¨ HTTPSï¼ˆå¾®ä¿¡å¼€æ”¾å¹³å°è¦æ±‚ï¼‰
    let finalCallbackUrl = callbackUrl
    if (!callbackUrl.includes('localhost') && callbackUrl.startsWith('http://')) {
      finalCallbackUrl = callbackUrl.replace('http://', 'https://')
      console.warn('âš ï¸ [WeChat] è‡ªåŠ¨å°† HTTP è½¬æ¢ä¸º HTTPS:', finalCallbackUrl)
    }

    const state = Math.random().toString(36).substr(2)

    // æ„é€ å¾®ä¿¡æˆæƒURLï¼ˆç½‘ç«™åº”ç”¨ - æ‰«ç ç™»å½•ï¼‰
    const authUrl =
      `https://open.weixin.qq.com/connect/qrconnect?` +
      `appid=${appid}&` +
      `redirect_uri=${encodeURIComponent(finalCallbackUrl)}&` +
      `response_type=code&` +
      `scope=snsapi_login&` +
      `state=${state}#wechat_redirect`

    console.log('ğŸ” [WeChat] æˆæƒ URL:', authUrl)
    console.log('ğŸ”— [WeChat] å›è°ƒåœ°å€:', finalCallbackUrl)

    return NextResponse.json({
      success: true,
      authUrl,
    })
  } catch (error: any) {
    console.error('âŒ æ„é€ å¾®ä¿¡æˆæƒURLå¤±è´¥:', error)
    return NextResponse.json(
      { error: 'æ„é€ æˆæƒURLå¤±è´¥' },
      { status: 500 }
    )
  }
}
=== /Users/8086k/project/components/app/api/auth/wechat/route.ts ===
import { NextRequest, NextResponse } from 'next/server'
import { wechatAuth } from '@/lib/wechat-auth'

export async function GET(request: NextRequest) {
  try {
    const authUrl = wechatAuth.getAuthUrl()
    return NextResponse.redirect(authUrl)
  } catch (error) {
    console.error('WeChat auth error:', error)
    return NextResponse.json(
      { error: 'WeChat OAuth not configured properly' },
      { status: 500 }
    )
  }
} === /Users/8086k/project/components/app/api/geo/detect/route.ts ===
import { NextRequest, NextResponse } from 'next/server'
import {
  getRegionFromCountryCode,
  getDefaultLanguage,
  getPaymentMethodsByRegion,
  getCurrencyByRegion,
  isEuropeanCountry,
  type Region,
  type Language
} from '@/lib/ip-detection'

// å†…å­˜ç¼“å­˜ï¼Œé¿å…é‡å¤è¯·æ±‚ç›¸åŒçš„IP
const geoCache = new Map<string, { data: GeoLocation; timestamp: number }>()
const CACHE_DURATION = 1000 * 60 * 30 // 30åˆ†é’Ÿç¼“å­˜

/**
 * IP åœ°ç†ä½ç½®æ£€æµ‹ API (å‡çº§ç‰ˆ)
 *
 * åŠŸèƒ½ï¼š
 * 1. æ£€æµ‹ç”¨æˆ· IP åœ°å€
 * 2. è¿”å›å›½å®¶ä»£ç ã€è´§å¸ã€è¯­è¨€ç­‰ä¿¡æ¯
 * 3. åŒºåŸŸåˆ†ç±»ï¼šä¸­å›½ã€ç¾å›½ã€å°åº¦ã€æ–°åŠ å¡ã€æ¬§æ´²ã€å…¶ä»–
 * 4. æ¬§æ´²åœ°åŒºæ ‡è¯†ï¼ˆç”¨äºGDPRåˆè§„ï¼‰
 * 5. è‡ªåŠ¨è¯­è¨€è¯†åˆ«ï¼ˆä¸­æ–‡/è‹±æ–‡ï¼‰
 *
 * ä½¿ç”¨ ip-api.com å…è´¹æœåŠ¡ (æ— éœ€æ³¨å†Œï¼Œæ¯åˆ†é’Ÿ45æ¬¡è¯·æ±‚)
 */

export interface GeoLocation {
  country: string        // å›½å®¶åç§° (e.g., "China", "United States")
  countryCode: string    // å›½å®¶ä»£ç  (e.g., "CN", "US")
  region: string         // åœ°åŒºä»£ç  (e.g., "BJ", "CA")
  regionName: string     // åœ°åŒºåç§° (e.g., "Beijing", "California")
  city: string           // åŸå¸‚ (e.g., "Beijing", "Los Angeles")
  timezone: string       // æ—¶åŒº (e.g., "Asia/Shanghai")
  currency: string       // æ¨èè´§å¸ (e.g., "CNY", "USD")
  language: string       // æ¨èè¯­è¨€ (e.g., "zh-CN", "en-US")
  paymentMethods: string[] // æ¨èæ”¯ä»˜æ–¹å¼
  ip: string            // IPåœ°å€
  regionCategory: Region // åŒºåŸŸåˆ†ç±» (æ–°å¢)
  languageCode: Language // è¯­è¨€ä»£ç  (æ–°å¢)
  isEurope: boolean     // æ˜¯å¦æ¬§æ´² (æ–°å¢)
}

// ä»è¯·æ±‚å¤´è·å–çœŸå® IP
function getClientIP(request: NextRequest): string {
  // å°è¯•ä»å„ç§ä»£ç†å¤´è·å–çœŸå® IP
  const forwarded = request.headers.get('x-forwarded-for')
  const realIP = request.headers.get('x-real-ip')
  const cfConnectingIP = request.headers.get('cf-connecting-ip') // Cloudflare

  if (cfConnectingIP) return cfConnectingIP
  if (realIP) return realIP
  if (forwarded) return forwarded.split(',')[0].trim()

  // å¼€å‘ç¯å¢ƒï¼šå¦‚æœæ£€æµ‹ä¸åˆ° IPï¼Œè¿”å› null è®© API å¤„ç†é”™è¯¯
  return ''
}

export async function GET(request: NextRequest) {
  try {
    const clientIP = getClientIP(request)

    // å¦‚æœæ²¡æœ‰è·å–åˆ° IPï¼Œç›´æ¥è¿”å›é»˜è®¤é…ç½®
    if (!clientIP) {
      console.log('âš ï¸ [Geo] No IP detected, using default configuration')
      const defaultLocation: GeoLocation = {
        country: 'United States',
        countryCode: 'US',
        region: '',
        regionName: '',
        city: '',
        timezone: 'America/New_York',
        currency: 'USD',
        language: 'en-US',
        paymentMethods: ['stripe', 'paypal'],
        ip: 'unknown',
        regionCategory: 'usa',
        languageCode: 'en',
        isEurope: false
      }
      return NextResponse.json({
        success: false,
        error: 'No IP detected',
        data: defaultLocation
      })
    }

    // æ£€æŸ¥ç¼“å­˜
    const now = Date.now()
    const cached = geoCache.get(clientIP)
    if (cached && (now - cached.timestamp) < CACHE_DURATION) {
      console.log(`âœ… [Geo] ä½¿ç”¨ç¼“å­˜æ•°æ® for IP: ${clientIP}`)
      return NextResponse.json({
        success: true,
        data: cached.data,
        cached: true
      })
    }

    console.log(`ğŸŒ [Geo] è¯·æ±‚æ–°çš„åœ°ç†ä½ç½®æ•°æ® for IP: ${clientIP}`)

    // è°ƒç”¨ ip-api.com è·å–åœ°ç†ä½ç½®ä¿¡æ¯
    const response = await fetch(`http://ip-api.com/json/${clientIP}?fields=status,message,country,countryCode,region,regionName,city,timezone,query`, {
      headers: {
        'Accept': 'application/json'
      }
    })

    if (!response.ok) {
      throw new Error('IP-API request failed')
    }

    const data = await response.json()

    // æ£€æŸ¥ API å“åº”çŠ¶æ€
    if (data.status !== 'success') {
      throw new Error(data.message || 'IP detection failed')
    }

    // è·å–å›½å®¶ä»£ç å’ŒåŒºåŸŸåˆ†ç±»
    const countryCode = data.countryCode || 'US'
    const regionCategory = getRegionFromCountryCode(countryCode)
    const languageCode = getDefaultLanguage(regionCategory)
    const isEurope = isEuropeanCountry(countryCode)

    // è·å–åŒºåŸŸé…ç½®
    const currency = getCurrencyByRegion(regionCategory)
    const paymentMethods = getPaymentMethodsByRegion(regionCategory)

    // æ„é€ è¿”å›æ•°æ®
    const geoLocation: GeoLocation = {
      country: data.country,
      countryCode: countryCode,
      region: data.region,
      regionName: data.regionName,
      city: data.city,
      timezone: data.timezone,
      currency: currency,
      language: languageCode === 'zh' ? 'zh-CN' : 'en-US',
      paymentMethods: paymentMethods,
      ip: data.query || clientIP,
      regionCategory: regionCategory,
      languageCode: languageCode,
      isEurope: isEurope
    }

    // å­˜å…¥ç¼“å­˜
    geoCache.set(clientIP, { data: geoLocation, timestamp: now })

    // æ¸…ç†è¿‡æœŸç¼“å­˜
    if (geoCache.size > 1000) { // é˜²æ­¢å†…å­˜æ³„æ¼
      const cutoff = now - CACHE_DURATION
      for (const [ip, entry] of geoCache.entries()) {
        if (entry.timestamp < cutoff) {
          geoCache.delete(ip)
        }
      }
    }

    return NextResponse.json({
      success: true,
      data: geoLocation,
      cached: false
    })

  } catch (error) {
    console.error('IP detection error:', error)

    // è¿”å›é»˜è®¤é…ç½®ï¼ˆå‡è®¾ä¸ºç¾å›½ç”¨æˆ·ï¼‰
    const defaultLocation: GeoLocation = {
      country: 'United States',
      countryCode: 'US',
      region: '',
      regionName: '',
      city: '',
      timezone: 'America/New_York',
      currency: 'USD',
      language: 'en-US',
      paymentMethods: ['stripe', 'paypal'],
      ip: 'unknown',
      regionCategory: 'usa',
      languageCode: 'en',
      isEurope: false
    }

    return NextResponse.json({
      success: false,
      error: error instanceof Error ? error.message : 'IP detection failed',
      data: defaultLocation // è¿”å›é»˜è®¤å€¼ç¡®ä¿åº”ç”¨å¯ç”¨
    })
  }
}

// æ”¯æŒ POST è¯·æ±‚ï¼ˆç”¨äºæŒ‡å®š IP æµ‹è¯•ï¼‰
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const testIP = body.ip || getClientIP(request)

    const response = await fetch(`http://ip-api.com/json/${testIP}?fields=status,message,country,countryCode,region,regionName,city,timezone,query`)
    const data = await response.json()

    if (data.status !== 'success') {
      throw new Error(data.message || 'IP detection failed')
    }

    const countryCode = data.countryCode || 'US'
    const regionCategory = getRegionFromCountryCode(countryCode)
    const languageCode = getDefaultLanguage(regionCategory)
    const isEurope = isEuropeanCountry(countryCode)

    const currency = getCurrencyByRegion(regionCategory)
    const paymentMethods = getPaymentMethodsByRegion(regionCategory)

    const geoLocation: GeoLocation = {
      country: data.country,
      countryCode: countryCode,
      region: data.region,
      regionName: data.regionName,
      city: data.city,
      timezone: data.timezone,
      currency: currency,
      language: languageCode === 'zh' ? 'zh-CN' : 'en-US',
      paymentMethods: paymentMethods,
      ip: data.query || testIP,
      regionCategory: regionCategory,
      languageCode: languageCode,
      isEurope: isEurope
    }

    return NextResponse.json({
      success: true,
      data: geoLocation
    })

  } catch (error) {
    return NextResponse.json({
      success: false,
      error: error instanceof Error ? error.message : 'IP detection failed'
    }, { status: 500 })
  }
}
=== /Users/8086k/project/components/app/api/payment/alipay/create/route.ts ===
import { NextRequest, NextResponse } from 'next/server'
import { AlipaySdk } from 'alipay-sdk'
import { createClient } from '@supabase/supabase-js'
import { createDatabaseAdapter } from '@/lib/database/adapter'
import { CloudBaseAdapter } from '@/lib/database/cloudbase-adapter'
import { SupabaseAdapter } from '@/lib/database/supabase-adapter'

// æ”¯ä»˜å®æ”¯ä»˜é…ç½® - åªæ”¯æŒå…¬é’¥æ¨¡å¼
const alipayConfig = {
  appId: process.env.ALIPAY_APP_ID,
  privateKey: process.env.ALIPAY_PRIVATE_KEY,
  alipayPublicKey: process.env.ALIPAY_PUBLIC_KEY,
  gateway: process.env.ALIPAY_GATEWAY,
  signType: 'RSA2',
  charset: 'utf-8',
  version: '1.0',
  timeout: 30000,
  camelcase: false, // ä½¿ç”¨ä¸‹åˆ’çº¿å‘½å
}

// å®šä»·é…ç½®ï¼ˆä¸ Stripe/PayPal ä¿æŒä¸€è‡´ï¼‰
const pricingConfig = {
  pro: {
    monthly: 19.99, // æ­£å¼ä»·æ ¼ $19.99/æœˆ
    yearly: 168,   // æ­£å¼ä»·æ ¼ $168/å¹´
  },
  team: {
    monthly: 299.99, // æ­£å¼ä»·æ ¼ $299.99/æœˆ
    yearly: 2520,  // æ­£å¼ä»·æ ¼ $2520/å¹´
  },
}

// æ±‡ç‡é…ç½®ï¼ˆç¾å…ƒè½¬äººæ°‘å¸ï¼Œå‡è®¾æ±‡ç‡ 1 USD = 7.2 CNYï¼‰
const USD_TO_CNY_RATE = 7.2

// åœ°åŒºæ£€æµ‹
const DEPLOYMENT_REGION = process.env.NEXT_PUBLIC_DEPLOYMENT_REGION || 'china'
const IS_CHINA_DEPLOYMENT = DEPLOYMENT_REGION === 'china'

// ç”Ÿæˆå”¯ä¸€çš„æ”¯ä»˜IDï¼ˆä¸mvp_modules-mainä¿æŒä¸€è‡´ï¼‰
function generatePaymentId(): string {
  return `pay_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

export async function POST(req: NextRequest) {
  try {
    console.log('ğŸ”µ [Alipay] å¼€å§‹åˆ›å»ºæ”¯ä»˜è®¢å•...', { region: DEPLOYMENT_REGION })

    // æ£€æŸ¥æ”¯ä»˜å®é…ç½®
    console.log('ğŸ” [Alipay] æ£€æŸ¥ç¯å¢ƒå˜é‡é…ç½®:', {
      ALIPAY_APP_ID: alipayConfig.appId ? 'å·²é…ç½®' : 'æœªé…ç½®',
      ALIPAY_PRIVATE_KEY: alipayConfig.privateKey ? 'å·²é…ç½®' : 'æœªé…ç½®',
      ALIPAY_PUBLIC_KEY: alipayConfig.alipayPublicKey ? 'å·²é…ç½®' : 'æœªé…ç½®',
      ALIPAY_GATEWAY: alipayConfig.gateway ? 'å·²é…ç½®' : 'æœªé…ç½®',
    })

    if (!alipayConfig.appId || !alipayConfig.privateKey || !alipayConfig.alipayPublicKey) {
      console.error('âŒ [Alipay] é…ç½®ç¼ºå¤±:', {
        hasAppId: !!alipayConfig.appId,
        hasPrivateKey: !!alipayConfig.privateKey,
        hasPublicKey: !!alipayConfig.alipayPublicKey,
        ALIPAY_APP_ID: alipayConfig.appId || 'null/undefined',
      })
      return NextResponse.json(
        {
          error: 'Alipay payment is currently unavailable. Please use Stripe or PayPal.',
          errorCode: 'ALIPAY_NOT_CONFIGURED',
          details: 'Alipay credentials are not configured. Contact support.',
        },
        { status: 503 }
      )
    }

    // ç±»å‹æ–­è¨€ï¼šæ­¤æ—¶é…ç½®å·²éªŒè¯ä¸ä¸ºundefined
    const validatedConfig = alipayConfig as {
      appId: string;
      privateKey: string;
      alipayPublicKey: string;
      gateway: string;
      signType: string;
      charset: string;
      version: string;
      timeout: number;
      camelcase: boolean;
    }

    const body = await req.json()
    const { planType, billingCycle, userEmail, userId: requestUserId } = body

    console.log('ğŸ“ [Alipay] è®¢å•ä¿¡æ¯:', { planType, billingCycle, userEmail, userId: requestUserId })

    // è·å–ç”¨æˆ·ä¿¡æ¯ï¼ˆç”¨äºæ•°æ®åº“é€‚é…å™¨ï¼‰
    const authHeader = req.headers.get('authorization')
    let userId = requestUserId || ''

    if (authHeader) {
      // å¦‚æœæœ‰è®¤è¯å¤´ï¼Œè§£æç”¨æˆ·ä¿¡æ¯
      try {
        const token = authHeader.replace('Bearer ', '')
        // è¿™é‡Œéœ€è¦æ ¹æ®ä½ çš„è®¤è¯ç³»ç»Ÿè§£ætokenè·å–ç”¨æˆ·IDå’Œé‚®ç®±
        // æš‚æ—¶ä»è¯·æ±‚ä½“è·å–
      } catch (error) {
        console.warn('âš ï¸ [Alipay] æ— æ³•è§£æè®¤è¯token')
      }
    }

    if (!userId && IS_CHINA_DEPLOYMENT) {
      console.error('âŒ [Alipay] å›½å†…ç‰ˆéœ€è¦æä¾›userId')
      return NextResponse.json(
        { error: 'User ID is required for domestic deployment' },
        { status: 400 }
      )
    }

    // éªŒè¯è¾“å…¥
    if (!planType || !billingCycle || !userEmail) {
      return NextResponse.json(
        { error: 'Missing required fields: planType, billingCycle, userEmail' },
        { status: 400 }
      )
    }

    if (!['pro', 'team'].includes(planType)) {
      return NextResponse.json({ error: 'Invalid plan type' }, { status: 400 })
    }

    if (!['monthly', 'yearly'].includes(billingCycle)) {
      return NextResponse.json({ error: 'Invalid billing cycle' }, { status: 400 })
    }

    // è®¡ç®—ä»·æ ¼ï¼ˆç¾å…ƒï¼‰
    const amountUSD = pricingConfig[planType as 'pro' | 'team'][billingCycle as 'monthly' | 'yearly']

    // è½¬æ¢ä¸ºäººæ°‘å¸
    const amountCNY = (amountUSD * USD_TO_CNY_RATE).toFixed(2)

    console.log('ğŸ’° [Alipay] ä»·æ ¼è®¡ç®—:', {
      amountUSD: `$${amountUSD}`,
      amountCNY: `Â¥${amountCNY}`,
      rate: USD_TO_CNY_RATE,
    })

    // ç”Ÿæˆè®¢å•å·ï¼ˆä¸mvp_modules-mainä¿æŒä¸€è‡´ï¼‰
    const outTradeNo = generatePaymentId()

    // è®¢å•æè¿°ï¼ˆä¸mvp_modules-mainä¿æŒä¸€è‡´ï¼‰
    const description = `${billingCycle === "monthly" ? "1 Month" : "1 Year"} Premium Membership (One-time Payment)`

    // åˆå§‹åŒ–æ”¯ä»˜å® SDK
    const alipaySdk = new AlipaySdk(validatedConfig as any)

    // è½¬æ¢é‡‘é¢ä¸ºæ•°å­—ï¼ˆä¸mvp_modules-mainä¿æŒä¸€è‡´ï¼‰
    const amountNum = parseFloat(amountCNY)

    // åˆ›å»ºæ”¯ä»˜å®è®¢å•å‚æ•°ï¼ˆä¸mvp_modules-mainå®Œå…¨ä¸€è‡´ï¼‰
    const bizContent = {
      out_trade_no: outTradeNo, // å¿…éœ€ï¼šå•†æˆ·è®¢å•å·
      total_amount: amountNum.toFixed(2), // å¿…éœ€ï¼šè®¢å•æ€»é‡‘é¢ï¼Œå•ä½å…ƒï¼Œç²¾ç¡®åˆ°å°æ•°ç‚¹åä¸¤ä½
      subject: description, // å¿…éœ€ï¼šè®¢å•æ ‡é¢˜ï¼Œæœ€é•¿256å­—ç¬¦ï¼ˆä½¿ç”¨descriptionè€Œä¸æ˜¯è‡ªå®šä¹‰å­—ç¬¦ä¸²ï¼‰
      product_code: 'FAST_INSTANT_TRADE_PAY', // ç”µè„‘ç½‘ç«™æ”¯ä»˜
      passback_params: userId || "", // âœ… ä¼ é€’ç”¨æˆ·IDï¼Œæ”¯ä»˜å®ä¼šåŸæ ·è¿”å›
      // âœ… é‡è¦ï¼šnotify_url å’Œ return_url å¿…é¡»åœ¨ bizContent ä¸­ï¼Œæ”¯ä»˜å®æ‰ä¼šå¼‚æ­¥å›è°ƒ
      notify_url: `${process.env.NEXT_PUBLIC_SITE_URL}/api/payment/alipay/notify`,
      return_url: `${process.env.NEXT_PUBLIC_SITE_URL}/payment/success?session_id=${outTradeNo}`,
    }

    console.log('ğŸ“¤ [Alipay] æ”¯ä»˜å®è¯·æ±‚å‚æ•°:', { bizContent })

    // ç”Ÿæˆæ”¯ä»˜é“¾æ¥ï¼ˆä¸mvp_modules-mainå®Œå…¨ä¸€è‡´ï¼‰
    const method = 'alipay.trade.page.pay'
    const orderData = {
      method,
      bizContent,
    }

    const paymentUrl = await (alipaySdk as any).pageExec(orderData.method, {
      return_url: orderData.bizContent.return_url,
      notify_url: orderData.bizContent.notify_url,
      bizContent: orderData.bizContent,
    })

    console.log('âœ… [Alipay] æ”¯ä»˜é“¾æ¥ç”ŸæˆæˆåŠŸ')

    // ä¿å­˜è®¢å•åˆ°æ•°æ®åº“ï¼ˆä½¿ç”¨æ•°æ®åº“é€‚é…å™¨ï¼‰
    const amountInCents = Math.round(parseFloat(amountCNY) * 100) // è½¬æ¢ä¸ºåˆ†
    const paymentFee = Math.round(amountInCents * 0.006) // æ”¯ä»˜å®æ‰‹ç»­è´¹çº¦ 0.6%
    const netAmount = amountInCents - paymentFee

    try {
      console.log('ğŸ”§ [Alipay] å‡†å¤‡ä¿å­˜è®¢å•åˆ°æ•°æ®åº“...', { userId, IS_CHINA_DEPLOYMENT })

      // åˆ›å»ºæ•°æ®åº“é€‚é…å™¨
      const dbAdapter = IS_CHINA_DEPLOYMENT ?
        new CloudBaseAdapter(userId) :
        new SupabaseAdapter(userId)

      console.log('ğŸ”§ [Alipay] æ•°æ®åº“é€‚é…å™¨åˆ›å»ºæˆåŠŸ')

      // é€‚é…ä¸åŒæ•°æ®åº“çš„å­—æ®µç»“æ„
      const transactionData = IS_CHINA_DEPLOYMENT ? {
        // CloudBaseå­—æ®µç»“æ„
        user_id: userId,
        product_name: 'sitehub',
        plan_type: planType,
        billing_cycle: billingCycle,
        payment_method: 'alipay',
        payment_status: 'pending',
        transaction_type: 'purchase',
        currency: 'CNY',
        gross_amount: amountInCents,
        payment_fee: paymentFee,
        net_amount: netAmount,
        profit: netAmount,
        transaction_id: outTradeNo,
        payment_time: new Date().toISOString()
      } : {
        // Supabaseå­—æ®µç»“æ„
        user_email: userEmail,
        plan_type: planType,
        billing_cycle: billingCycle,
        amount_usd: amountUSD,
        amount_cny: parseFloat(amountCNY),
        payment_method: 'alipay',
        transaction_id: outTradeNo,
        status: 'pending'
      }

      console.log('ğŸ”§ [Alipay] å‡†å¤‡ä¿å­˜æ•°æ®:', transactionData)

      const saveSuccess = await dbAdapter.savePaymentTransaction(transactionData)

      if (!saveSuccess) {
        console.error('âš ï¸ [Alipay] æ•°æ®åº“ä¿å­˜å¤±è´¥ (ä¸å½±å“æ”¯ä»˜)')
      } else {
        console.log('âœ… [Alipay] è®¢å•å·²ä¿å­˜åˆ°æ•°æ®åº“')
      }
    } catch (dbError) {
      console.error('âš ï¸ [Alipay] æ•°æ®åº“æ“ä½œå¼‚å¸¸ (ä¸å½±å“æ”¯ä»˜):', dbError)
      console.error('âš ï¸ [Alipay] é”™è¯¯è¯¦æƒ…:', {
        message: dbError instanceof Error ? dbError.message : String(dbError),
        stack: dbError instanceof Error ? dbError.stack : undefined,
        userId,
        IS_CHINA_DEPLOYMENT
      })
    }

    // è¿”å›æ”¯ä»˜é“¾æ¥
    return NextResponse.json({
      paymentUrl,
      orderId: outTradeNo,
      amount: amountCNY,
      currency: 'CNY',
    })
  } catch (error) {
    console.error('âŒ [Alipay] è®¢å•åˆ›å»ºå¤±è´¥:', error)
    return NextResponse.json(
      {
        error: 'Failed to create Alipay order',
        details: error instanceof Error ? error.message : 'Unknown error',
      },
      { status: 500 }
    )
  }
}
=== /Users/8086k/project/components/app/api/payment/alipay/notify/route.ts ===
import { NextRequest, NextResponse } from 'next/server'
import { AlipaySdk } from 'alipay-sdk'
import { createClient } from '@supabase/supabase-js'
import { CloudBaseAdapter } from '@/lib/database/cloudbase-adapter'
import { SupabaseAdapter } from '@/lib/database/supabase-adapter'

// æ”¯ä»˜å®é…ç½®ï¼ˆå®Œå…¨ä½¿ç”¨ .env.local ä¸­çš„å€¼ï¼‰
const alipayConfig = {
  appId: process.env.ALIPAY_APP_ID,
  privateKey: process.env.ALIPAY_PRIVATE_KEY,
  alipayPublicKey: process.env.ALIPAY_PUBLIC_KEY,
  gateway: process.env.ALIPAY_GATEWAY,
  signType: 'RSA2',
  charset: 'utf-8',
  version: '1.0',
}

// åœ°åŒºæ£€æµ‹
const DEPLOYMENT_REGION = process.env.NEXT_PUBLIC_DEPLOYMENT_REGION || 'china'
const IS_CHINA_DEPLOYMENT = DEPLOYMENT_REGION === 'china'

/**
 * POST - æ”¯ä»˜å®å¼‚æ­¥é€šçŸ¥å›è°ƒ
 * æ”¯ä»˜å®ä¼šåœ¨æ”¯ä»˜æˆåŠŸåè°ƒç”¨æ­¤æ¥å£
 */
export async function POST(req: NextRequest) {
  try {
    console.log('ğŸ”” [Alipay Notify] æ”¶åˆ°æ”¯ä»˜å®å›è°ƒé€šçŸ¥', { region: DEPLOYMENT_REGION })

    // æ£€æŸ¥é…ç½®
    if (!alipayConfig.appId || !alipayConfig.privateKey || !alipayConfig.alipayPublicKey) {
      console.error('âŒ [Alipay Notify] é…ç½®ç¼ºå¤±')
      return new NextResponse('fail', { status: 503 })
    }

    // è·å–POSTæ•°æ®
    const formData = await req.formData()
    const params: Record<string, string> = {}

    formData.forEach((value, key) => {
      params[key] = value.toString()
    })

    console.log('ğŸ“ [Alipay Notify] å›è°ƒå‚æ•°:', {
      out_trade_no: params.out_trade_no,
      trade_no: params.trade_no,
      trade_status: params.trade_status,
      total_amount: params.total_amount,
    })

    // åˆå§‹åŒ–æ”¯ä»˜å® SDK
    const alipaySdk = new AlipaySdk(alipayConfig)

    // éªŒè¯ç­¾å
    const signVerified = alipaySdk.checkNotifySign(params)

    if (!signVerified) {
      console.error('âŒ [Alipay Notify] ç­¾åéªŒè¯å¤±è´¥')
      return new NextResponse('fail', { status: 400 })
    }

    console.log('âœ… [Alipay Notify] ç­¾åéªŒè¯é€šè¿‡')

    // æå–å…³é”®ä¿¡æ¯
    const {
      out_trade_no, // å•†æˆ·è®¢å•å·
      trade_no, // æ”¯ä»˜å®äº¤æ˜“å·
      trade_status, // äº¤æ˜“çŠ¶æ€
      total_amount, // è®¢å•é‡‘é¢
      passback_params, // âœ… ä» passback_params è·å–ç”¨æˆ·é‚®ç®±ï¼ˆåˆ›å»ºè®¢å•æ—¶ä¼ é€’ï¼‰
    } = params
    
    // ä» passback_params æå– userEmailï¼ˆå¦‚æœå­˜åœ¨ï¼‰
    const userEmail = passback_params || ''

    // æ›´æ–°æ•°æ®åº“è®¢å•çŠ¶æ€
    if (trade_status === 'TRADE_SUCCESS' || trade_status === 'TRADE_FINISHED') {
      console.log('ğŸ’° [Alipay Notify] æ”¯ä»˜æˆåŠŸï¼Œæ›´æ–°è®¢å•çŠ¶æ€')

      let transaction: any = null
      let finalUserEmail = userEmail
      let userId = ''

      try {
        if (IS_CHINA_DEPLOYMENT) {
          // CloudBaseé€»è¾‘ï¼šéœ€è¦å…ˆæŸ¥è¯¢è®¢å•è·å–ç”¨æˆ·ä¿¡æ¯
          const cloudbaseAdapter = new CloudBaseAdapter('')
          transaction = await cloudbaseAdapter.getPaymentTransaction(out_trade_no)

          if (!transaction) {
            console.error('âŒ [Alipay Notify] CloudBaseæœªæ‰¾åˆ°è®¢å•è®°å½•:', out_trade_no)
            return new NextResponse('success', {
              status: 200,
              headers: { 'Content-Type': 'text/plain' },
            })
          }

          userId = transaction.user_id
          // CloudBaseä¸­å¯èƒ½æ²¡æœ‰ç›´æ¥çš„é‚®ç®±ï¼Œéœ€è¦ä»ç”¨æˆ·ä¿¡æ¯ä¸­è·å–
          finalUserEmail = transaction.user_email || userEmail
        } else {
          // Supabaseé€»è¾‘
          const supabaseAdapter = new SupabaseAdapter('')
          transaction = await supabaseAdapter.getPaymentTransaction(out_trade_no)

          if (!transaction) {
            console.error('âŒ [Alipay Notify] Supabaseæœªæ‰¾åˆ°è®¢å•è®°å½•:', out_trade_no)
            return new NextResponse('success', {
              status: 200,
              headers: { 'Content-Type': 'text/plain' },
            })
          }

          finalUserEmail = transaction.user_email || userEmail
          userId = transaction.user_id
        }

        console.log('ğŸ“¦ [Alipay Notify] è®¢å•ä¿¡æ¯:', {
          email: finalUserEmail,
          plan: transaction.plan_type,
          cycle: transaction.billing_cycle,
          db: IS_CHINA_DEPLOYMENT ? 'CloudBase' : 'Supabase'
        })

        if (!finalUserEmail) {
          console.error('âŒ [Alipay Notify] æ— æ³•è·å–ç”¨æˆ·é‚®ç®±')
          return new NextResponse('success', {
            status: 200,
            headers: { 'Content-Type': 'text/plain' },
          })
        }

        // æ›´æ–°è®¢å•çŠ¶æ€
        if (IS_CHINA_DEPLOYMENT) {
          const cloudbaseAdapter = new CloudBaseAdapter(userId)
          const updateSuccess = await cloudbaseAdapter.updatePaymentStatus(out_trade_no, 'completed')
          if (!updateSuccess) {
            console.error('âŒ [Alipay Notify] CloudBaseæ›´æ–°å¤±è´¥')
          } else {
            console.log('âœ… [Alipay Notify] CloudBaseè®¢å•çŠ¶æ€å·²æ›´æ–°ä¸º completed')
          }
        } else {
          const supabaseAdapter = new SupabaseAdapter(userId)
          const updateSuccess = await supabaseAdapter.updatePaymentStatus(out_trade_no, 'completed')
          if (!updateSuccess) {
            console.error('âŒ [Alipay Notify] Supabaseæ›´æ–°å¤±è´¥')
          } else {
            console.log('âœ… [Alipay Notify] Supabaseè®¢å•çŠ¶æ€å·²æ›´æ–°ä¸º completed')
          }
        }

        // è®¡ç®—è®¢é˜…åˆ°æœŸæ—¶é—´
        const now = new Date()
        const expireTime = new Date(now)
        if (transaction.billing_cycle === 'monthly') {
          expireTime.setMonth(expireTime.getMonth() + 1)
        } else {
          expireTime.setFullYear(expireTime.getFullYear() + 1)
        }

        console.log('ğŸ“… Alipay subscription period:', {
          planType: transaction.plan_type,
          billingCycle: transaction.billing_cycle,
          startTime: now.toISOString(),
          expireTime: expireTime.toISOString(),
          db: IS_CHINA_DEPLOYMENT ? 'CloudBase' : 'Supabase'
        })

        // æ›´æ–°æˆ–åˆ›å»ºç”¨æˆ·è®¢é˜…
        const subscriptionData = {
          user_email: finalUserEmail,
          platform: 'web',
          payment_method: 'alipay',
          plan_type: transaction.plan_type,
          billing_cycle: transaction.billing_cycle,
          status: 'active',
          start_time: now.toISOString(),
          expire_time: expireTime.toISOString(),
          alipay_trade_no: trade_no,
          auto_renew: false,
          next_billing_date: expireTime.toISOString(),
          updated_at: now.toISOString(),
        }

        if (IS_CHINA_DEPLOYMENT) {
          const cloudbaseAdapter = new CloudBaseAdapter(userId)
          const subSuccess = await cloudbaseAdapter.upsertSubscription(subscriptionData)
          if (!subSuccess) {
            console.error('âŒ [Alipay Notify] CloudBaseè®¢é˜…æ›´æ–°å¤±è´¥')
          } else {
            console.log('âœ… [Alipay Notify] CloudBaseç”¨æˆ·è®¢é˜…å·²æ¿€æ´»')
          }
        } else {
          const supabaseAdapter = new SupabaseAdapter(userId)
          const subSuccess = await supabaseAdapter.upsertSubscription(subscriptionData)
          if (!subSuccess) {
            console.error('âŒ [Alipay Notify] Supabaseè®¢é˜…æ›´æ–°å¤±è´¥')
          } else {
            console.log('âœ… [Alipay Notify] Supabaseç”¨æˆ·è®¢é˜…å·²æ¿€æ´»')
          }

          // æ›´æ–°ç”¨æˆ·çš„ pro çŠ¶æ€ï¼ˆä»…Supabaseéœ€è¦ï¼‰
          try {
            const supabaseClient = createClient(
              process.env.NEXT_PUBLIC_SUPABASE_URL!,
              process.env.SUPABASE_SERVICE_ROLE_KEY!
            )
            const { data: userData, error: userError } = await supabaseClient.auth.admin.listUsers()
            const user = userData?.users.find(u => u.email === finalUserEmail)

            if (user) {
              const { error: updateError } = await supabaseClient.auth.admin.updateUserById(
                user.id,
                {
                  user_metadata: {
                    ...user.user_metadata,
                    pro: true,
                    upgraded_at: now.toISOString()
                  }
                }
              )

              if (updateError) {
                console.error('Failed to update user pro status:', updateError)
              } else {
                console.log('âœ… User pro status updated:', finalUserEmail)
              }
            } else {
              console.warn('âš ï¸ User not found in auth.users:', finalUserEmail)
            }
          } catch (error) {
            console.error('Error updating user pro status:', error)
            // ä¸è¿”å›é”™è¯¯ï¼Œå› ä¸ºè®¢é˜…å·²ç»åˆ›å»ºæˆåŠŸ
          }
        }
      } catch (error) {
        console.error('âŒ [Alipay Notify] å¤„ç†æ”¯ä»˜æˆåŠŸé€»è¾‘æ—¶å‡ºé”™:', error)
        // å³ä½¿å¤„ç†å‡ºé”™ï¼Œä¹Ÿè¿”å›successç»™æ”¯ä»˜å®ï¼Œé¿å…é‡å¤é€šçŸ¥
      }
    } else if (trade_status === 'TRADE_CLOSED') {
      console.log('âš ï¸ [Alipay Notify] äº¤æ˜“å·²å…³é—­')

      // æ›´æ–°è®¢å•çŠ¶æ€ä¸ºå·²å…³é—­
      if (IS_CHINA_DEPLOYMENT) {
        // CloudBaseé€»è¾‘ï¼šå…ˆæŸ¥è¯¢è·å–userId
        const cloudbaseAdapter = new CloudBaseAdapter('')
        const transaction = await cloudbaseAdapter.getPaymentTransaction(out_trade_no)
        if (transaction) {
          const adapterWithUser = new CloudBaseAdapter(transaction.user_id)
          await adapterWithUser.updatePaymentStatus(out_trade_no, 'cancelled')
          console.log('âœ… [Alipay Notify] CloudBaseè®¢å•çŠ¶æ€å·²æ›´æ–°ä¸º cancelled')
        }
      } else {
        // Supabaseé€»è¾‘
        const supabaseAdapter = new SupabaseAdapter('')
        await supabaseAdapter.updatePaymentStatus(out_trade_no, 'cancelled')
        console.log('âœ… [Alipay Notify] Supabaseè®¢å•çŠ¶æ€å·²æ›´æ–°ä¸º cancelled')
      }
    }

    // è¿”å› success ç»™æ”¯ä»˜å®ï¼ˆå¿…é¡»è¿”å›çº¯æ–‡æœ¬ "success"ï¼‰
    console.log('âœ… [Alipay Notify] å›è°ƒå¤„ç†å®Œæˆï¼Œè¿”å› success')
    return new NextResponse('success', {
      status: 200,
      headers: {
        'Content-Type': 'text/plain',
      },
    })
  } catch (error) {
    console.error('âŒ [Alipay Notify] å›è°ƒå¤„ç†å¼‚å¸¸:', error)
    // è¿”å› fail ç»™æ”¯ä»˜å®ï¼Œæ”¯ä»˜å®ä¼šé‡è¯•
    return new NextResponse('fail', {
      status: 500,
      headers: {
        'Content-Type': 'text/plain',
      },
    })
  }
}

/**
 * GET - æ”¯ä»˜å®åŒæ­¥è¿”å›ï¼ˆç”¨æˆ·æ”¯ä»˜å®Œæˆåæµè§ˆå™¨è·³è½¬ï¼‰
 * è¿™ä¸ªæ¥å£ä¸»è¦ç”¨äºé¡µé¢è·³è½¬ï¼Œä¸å¤„ç†ä¸šåŠ¡é€»è¾‘ï¼ˆä¸šåŠ¡é€»è¾‘åœ¨POSTä¸­å¤„ç†ï¼‰
 */
export async function GET(req: NextRequest) {
  try {
    console.log('ğŸ”„ [Alipay Return] ç”¨æˆ·æ”¯ä»˜å®Œæˆï¼ŒåŒæ­¥è¿”å›')

    const searchParams = req.nextUrl.searchParams
    const params: Record<string, string> = {}

    searchParams.forEach((value, key) => {
      params[key] = value
    })

    console.log('ğŸ“ [Alipay Return] è¿”å›å‚æ•°:', {
      out_trade_no: params.out_trade_no,
      trade_no: params.trade_no,
      total_amount: params.total_amount,
    })

    // éªŒè¯ç­¾å
    if (alipayConfig.alipayPublicKey) {
      const alipaySdk = new AlipaySdk(alipayConfig)
      const signVerified = alipaySdk.checkNotifySign(params)

      if (!signVerified) {
        console.error('âŒ [Alipay Return] ç­¾åéªŒè¯å¤±è´¥')
  return NextResponse.redirect(`${process.env.NEXT_PUBLIC_SITE_URL}/payment/cancel`)
      }

      console.log('âœ… [Alipay Return] ç­¾åéªŒè¯é€šè¿‡')
    }

    // è·³è½¬åˆ°æˆåŠŸé¡µé¢ï¼ˆå¸¦è®¢å•å·ï¼‰
    const successUrl = new URL('/payment/success', process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3000')
    if (params.out_trade_no) {
      successUrl.searchParams.set('session_id', params.out_trade_no)
    }

    return NextResponse.redirect(successUrl.toString())
  } catch (error) {
    console.error('âŒ [Alipay Return] åŒæ­¥è¿”å›å¤„ç†å¼‚å¸¸:', error)
    return NextResponse.redirect(`${process.env.NEXT_PUBLIC_SITE_URL}/payment/cancel`)
  }
}
=== /Users/8086k/project/components/app/api/payment/alipay/verify/route.ts ===
import { NextRequest, NextResponse } from 'next/server'
import { AlipaySdk } from 'alipay-sdk'
import { createClient } from '@supabase/supabase-js'

// æ”¯ä»˜å®é…ç½®
const alipayConfig = {
  appId: process.env.ALIPAY_APP_ID,
  privateKey: process.env.ALIPAY_PRIVATE_KEY,
  alipayPublicKey: process.env.ALIPAY_PUBLIC_KEY,
  gateway: process.env.ALIPAY_GATEWAY,
  signType: 'RSA2',
  charset: 'utf-8',
  version: '1.0',
}

export async function GET(req: NextRequest) {
  try {
    const searchParams = req.nextUrl.searchParams
    const outTradeNo = searchParams.get('out_trade_no')

    if (!outTradeNo) {
      return NextResponse.json(
        { success: false, error: 'Missing out_trade_no parameter' },
        { status: 400 }
      )
    }

    console.log('ğŸ” [Alipay Verify] Verifying payment:', outTradeNo)

    // æ£€æŸ¥é…ç½®
    if (!alipayConfig.appId || !alipayConfig.privateKey || !alipayConfig.alipayPublicKey) {
      console.error('âŒ [Alipay Verify] é…ç½®ç¼ºå¤±')
      return NextResponse.json(
        { success: false, error: 'Alipay configuration missing' },
        { status: 500 }
      )
    }

    // åˆå§‹åŒ–æ”¯ä»˜å®SDK
    const alipaySdk = new AlipaySdk(alipayConfig as any)

    // æŸ¥è¯¢æ”¯ä»˜å®æ”¯ä»˜çŠ¶æ€
    const result = await alipaySdk.exec('alipay.trade.query', {
      bizContent: {
        out_trade_no: outTradeNo,
      },
    })

    console.log('ğŸ“Š [Alipay Verify] Query result:', result)

    if (result.code === '10000') {
      // æ”¯ä»˜æˆåŠŸ
      const tradeStatus = result.tradeStatus
      console.log('âœ… [Alipay Verify] Payment verified:', {
        out_trade_no: outTradeNo,
        trade_status: tradeStatus,
        trade_no: result.tradeNo,
        total_amount: result.totalAmount,
      })

      return NextResponse.json({
        success: true,
        trade_status: tradeStatus,
        trade_no: result.tradeNo,
        total_amount: result.totalAmount,
        out_trade_no: outTradeNo,
      })
    } else {
      // æŸ¥è¯¢å¤±è´¥æˆ–æ”¯ä»˜æœªå®Œæˆ
      console.log('âŒ [Alipay Verify] Payment not completed:', {
        code: result.code,
        msg: result.msg,
        sub_code: result.subCode,
        sub_msg: result.subMsg,
      })

      return NextResponse.json({
        success: false,
        error: result.msg || 'Payment not completed',
        code: result.code,
        trade_status: result.tradeStatus,
      })
    }
  } catch (error) {
    console.error('âŒ [Alipay Verify] Verification error:', error)
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Verification failed'
      },
      { status: 500 }
    )
  }
}


=== /Users/8086k/project/components/app/api/payment/paypal/capture/route.ts ===
import { NextRequest, NextResponse } from 'next/server'
import { Client, Environment, OrdersController } from '@paypal/paypal-server-sdk'
import { createClient } from '@supabase/supabase-js'

export async function POST(req: NextRequest) {
  try {
// åˆå§‹åŒ–PayPalå®¢æˆ·ç«¯
const client = new Client({
  clientCredentialsAuthCredentials: {
    oAuthClientId: process.env.NEXT_PUBLIC_PAYPAL_CLIENT_ID!,
    oAuthClientSecret: process.env.PAYPAL_CLIENT_SECRET!,
  },
  environment: process.env.PAYPAL_MODE === 'production'
    ? Environment.Production
    : Environment.Sandbox,
})

const ordersController = new OrdersController(client)

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
)

    const { orderId, planType, userEmail, billingCycle } = await req.json()

    console.log('ğŸŸ¡ PayPal capture request:', { orderId, planType, userEmail, billingCycle })

    if (!orderId || !planType || !userEmail) {
      return NextResponse.json(
        { error: 'Missing required fields: orderId, planType, userEmail' },
        { status: 400 }
      )
    }

    // æ•è·PayPalæ”¯ä»˜
    const request = {
      id: orderId,
      body: {},
    }

    console.log('ğŸ“¤ Calling PayPal captureOrder API...')
    const { body: order } = await ordersController.captureOrder(request)
    console.log('ğŸ“¥ PayPal capture response:', { id: order.id, status: order.status })

    // éªŒè¯æ”¯ä»˜çŠ¶æ€
    if (order.status !== 'COMPLETED') {
      console.error('âŒ PayPal order status not COMPLETED:', order.status)
      return NextResponse.json(
        { error: 'Payment not completed', status: order.status },
        { status: 400 }
      )
    }

    // è®¡ç®—è®¢é˜…åˆ°æœŸæ—¶é—´ï¼ˆä¼˜å…ˆä½¿ç”¨ billingCycleï¼Œå…¼å®¹æ—§æ•°æ®ï¼‰
    const now = new Date()
    const expireTime = new Date(now)
    const cycle = billingCycle || planType // å…¼å®¹æ—§æ•°æ®

    if (cycle === 'yearly' || planType === 'yearly') {
      expireTime.setFullYear(expireTime.getFullYear() + 1)
    } else {
      expireTime.setMonth(expireTime.getMonth() + 1)
    }

    console.log('ğŸ“… Subscription period:', {
      startTime: now.toISOString(),
      expireTime: expireTime.toISOString(),
      billingCycle: cycle
    })

    // è·å–æ”¯ä»˜é‡‘é¢
    const paymentAmount = order.purchaseUnits?.[0]?.payments?.captures?.[0]?.amount?.value || '0'
    const amountInCents = Math.round(parseFloat(paymentAmount) * 100)

    // æ›´æ–°Supabaseè®¢é˜…çŠ¶æ€ï¼ˆä½¿ç”¨ web_subscriptionsï¼‰
    const { data: subscriptionRows, error: subError } = await supabase.from('web_subscriptions').upsert({
      user_email: userEmail,
      platform: 'web',
      payment_method: 'paypal',
      plan_type: planType,
      billing_cycle: billingCycle || 'monthly', // ä¿å­˜è®¡è´¹å‘¨æœŸ
      status: 'active',
      start_time: now.toISOString(),
      expire_time: expireTime.toISOString(),
      auto_renew: false,
      next_billing_date: expireTime.toISOString(),
      paypal_order_id: orderId,
      updated_at: now.toISOString(),
    }, {
      onConflict: 'user_email'
    }).select().maybeSingle()

    if (subError) {
      console.error('Failed to update subscription:', subError)
      return NextResponse.json({ error: 'Database error' }, { status: 500 })
    }


================================================================================
ç¬¬ 663-692 é¡µ (å 30 é¡µ)
================================================================================
  "SoundCloud": "SoundCloud",
  "Bandcamp": "Bandcamp",
  "Last.fm": "Last.fm",
  "Deezer": "Deezer",
  "Apple Music": "Apple Music",
  "Pandora": "Pandora",
  "Snapchat": "Snapchat",
  "Clubhouse": "Clubhouse",
  "Mastodon": "Mastodon",
  "Signal": "Signal",
  "Viber": "Viber",
  "WeChat Work": "ä¼ä¸šå¾®ä¿¡",
  "DingTalk": "é’‰é’‰",
  "Feishu": "é£ä¹¦",
  "Tencent Meeting": "è…¾è®¯ä¼šè®®",
  "VooV Meeting": "è…¾è®¯ä¼šè®®å›½é™…ç‰ˆ",
  "Coinbase": "Coinbase",
  "Binance": "å¸å®‰",
  "Kraken": "Kraken",
  "Robinhood": "Robinhood",
  "E*TRADE": "E*TRADE",
  "Charles Schwab": "å˜‰ä¿¡ç†è´¢",
  "Fidelity": "å¯Œè¾¾",
  "Wise": "Wise",
  "Revolut": "Revolut",
  "N26": "N26",
  "Etsy": "Etsy",
  "AliExpress": "é€Ÿå–é€š",
  "Wish": "Wish",
  "Overstock": "Overstock",
  "Wayfair": "Wayfair",
  "Target": "Target",
  "Walmart": "æ²ƒå°”ç›",
  "Costco": "å¥½å¸‚å¤š",
  "Best Buy": "ç™¾æ€ä¹°",
  "Newegg": "æ–°è›‹",
  "BBC": "BBC",
  "CNN": "CNN",
  "Reuters": "è·¯é€ç¤¾",
  "AP News": "ç¾è”ç¤¾",
  "New York Times": "çº½çº¦æ—¶æŠ¥",
  "Wall Street Journal": "åå°”è¡—æ—¥æŠ¥",
  "The Guardian": "å«æŠ¥",
  "The Economist": "ç»æµå­¦äºº",
  "Forbes": "ç¦å¸ƒæ–¯",
  "TechCrunch": "TechCrunch",
  "The Verge": "The Verge",
  "Wired": "è¿çº¿",
  "Ars Technica": "Ars Technica",
  "Engadget": "Engadget",
  "Mashable": "Mashable",
  "BuzzFeed": "BuzzFeed",
  "VICE": "VICE",
  "1Password": "1Password",
  "LastPass": "LastPass",
  "Bitwarden": "Bitwarden",
  "NordVPN": "NordVPN",
  "ExpressVPN": "ExpressVPN",
  "Surfshark": "Surfshark",
  "Grammarly": "Grammarly",
  "DeepL": "DeepL",
  "Google Translate": "Google ç¿»è¯‘",
  "Wolfram Alpha": "Wolfram Alpha",
  "Calculator.net": "Calculator.net",
  "Convertio": "Convertio",
  "SmallPDF": "SmallPDF",
  "WeTransfer": "WeTransfer",
  "MEGA": "MEGA",
  "Box": "Box",
  "Zhihu Live": "çŸ¥ä¹Live",
  "Douyin Live": "æŠ–éŸ³ç›´æ’­",
  "Kuaishou Live": "å¿«æ‰‹ç›´æ’­",
  "Huya": "è™ç‰™ç›´æ’­",
  "Douyu": "æ–—é±¼ç›´æ’­",
  "YY": "YYè¯­éŸ³",
  "Miaopai": "ç§’æ‹",
  "JD Global": "äº¬ä¸œå…¨çƒ",
  "Tumblr": "Tumblr",
  "Zalando": "Zalando",
  "ASOS": "ASOS",
  "H&M": "H&M",
  "Zara": "Zara",
  "Disney+": "Disney+",
  "Hulu": "Hulu",
  "Prime Video": "Prime Video",
  "HBO Max": "HBO Max",
  "Paramount+": "Paramount+",
  "Peacock": "Peacock",
  "Apple TV+": "Apple TV+",
  "Crunchyroll": "Crunchyroll",
  "Tidal": "Tidal",
  "Amazon Music": "Amazon Music",
  "YouTube Music": "YouTube Music",
  "Terraform": "Terraform",
  "Ansible": "Ansible",
  "Adobe Creative": "Adobeåˆ›æ„",
  "Adobe XD": "Adobe XD",
  "Principle": "Principle",
  "ProtoPie": "ProtoPie",
  "Monday.com": "Monday.com",
  "ClickUp": "ClickUp",
  "Basecamp": "Basecamp",
  "edX": "edX",
  "Skillshare": "Skillshare",
  "MasterClass": "MasterClass",
  "LinkedIn Learning": "LinkedInå­¦ä¹ ",
  "Pluralsight": "Pluralsight",
  "Steam": "Steam",
  "Epic Games": "Epic Games",
  "Ubisoft": "è‚²ç¢§",
  "EA Games": "EAæ¸¸æˆ",
  "Activision": "åŠ¨è§†",
  "Roblox": "Roblox",
  "Booking.com": "Booking.com",
  "Kayak": "Kayak",
  "Skyscanner": "Skyscanner",
  "TripAdvisor": "çŒ«é€”é¹°",
  "Uber": "Uber",
  "Lyft": "Lyft",
  "MyFitnessPal": "MyFitnessPal",
  "Strava": "Strava",
  "Fitbit": "Fitbit",
  "Apple Health": "Appleå¥åº·",
  "Calm": "Calm",
  "Headspace": "Headspace",
  "Peloton": "Peloton",
  "Nike Training": "Nikeè®­ç»ƒ"
}
=== /Users/8086k/project/components/lib/supabase.ts ===
import { createClient } from './supabase/client'

export const supabase = createClient()

// Auth helper functions
export const auth = {
  // Sign up with email and password
  signUp: async (email: string, password: string) => {
    const { data, error } = await supabase.auth.signUp({
      email,
      password,
    })
    return { data, error }
  },

  // Sign in with email and password
  signIn: async (email: string, password: string) => {
    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password,
    })
    return { data, error }
  },

  // Sign in with Google
  signInWithGoogle: async () => {
    // ä½¿ç”¨ window.location.origin ä½œä¸ºå›è°ƒåœ°å€ï¼ˆå®¢æˆ·ç«¯è¿è¡Œæ—¶è·å–ï¼‰
    const { data, error } = await supabase.auth.signInWithOAuth({
      provider: 'google',
      options: {
        redirectTo: `${window.location.origin}/auth/callback`
      }
    })
    return { data, error }
  },

  // Sign in with Facebook
  signInWithFacebook: async () => {
    const { data, error } = await supabase.auth.signInWithOAuth({
      provider: 'facebook',
      options: {
        redirectTo: `${window.location.origin}/auth/callback`
      }
    })
    return { data, error }
  },

  // Sign in with WeChat (using custom OAuth)
  signInWithWeChat: async () => {
    // WeChat OAuth requires custom implementation since it's not a built-in Supabase provider
    // This would need to be implemented using WeChat's official SDK or a custom OAuth flow
    const error = new Error('WeChat authentication requires custom implementation')
    return { data: null, error }
  },

  // Sign in with phone number (OTP)
  signInWithPhone: async (phone: string) => {
    const { data, error } = await supabase.auth.signInWithOtp({
      phone: phone
    })
    return { data, error }
  },

  // Verify phone OTP code
  verifyPhoneOTP: async (phone: string, token: string) => {
    const { data, error } = await supabase.auth.verifyOtp({
      phone: phone,
      token: token,
      type: 'sms'
    })
    return { data, error }
  },

  // Sign out
  signOut: async () => {
    const { error } = await supabase.auth.signOut()
    return { error }
  },

  // Get current user
  getCurrentUser: async () => {
    const { data: { user }, error } = await supabase.auth.getUser()
    return { user, error }
  },

  // Get current session
  getCurrentSession: async () => {
    const { data: { session }, error } = await supabase.auth.getSession()
    return { session, error }
  },

  // Reset password with email
  resetPassword: async (email: string) => {
    const { data, error } = await supabase.auth.resetPasswordForEmail(email, {
      redirectTo: `${window.location.origin}/auth/reset-password`
    })
    return { data, error }
  },

  // Update password
  updatePassword: async (newPassword: string) => {
    const { data, error } = await supabase.auth.updateUser({
      password: newPassword
    })
    return { data, error }
  },

  // Listen to auth changes
  onAuthStateChange: (callback: (event: string, session: any) => void) => {
    return supabase.auth.onAuthStateChange(callback)
  }
} === /Users/8086k/project/components/lib/supabase/client.ts ===
import { createClient as createSupabaseClient } from '@supabase/supabase-js'

export function createClient() {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL
  const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY

  if (!supabaseUrl || !supabaseAnonKey) {
    console.warn('Missing Supabase environment variables, using mock client')
    // è¿”å›ä¸€ä¸ªæ¨¡æ‹Ÿçš„Supabaseå®¢æˆ·ç«¯ï¼Œé¿å…é”™è¯¯
    return {
      auth: {
        getSession: async () => ({ data: { session: null }, error: null }),
        signInWithOAuth: async () => ({ data: null, error: { message: 'Supabase not configured' } }),
        signInWithPassword: async () => ({ data: { user: null, session: null }, error: { message: 'Supabase not configured' } }),
        signUp: async () => ({ data: { user: null, session: null }, error: { message: 'Supabase not configured' } }),
        signOut: async () => ({ error: null }),
        onAuthStateChange: (callback: any) => {
          // ç«‹å³è°ƒç”¨callbackä»¥å®Œæˆåˆå§‹åŒ–
          setTimeout(() => callback('INITIAL_SESSION', null), 0)
          return { data: { subscription: { unsubscribe: () => {} } } }
        }
      },
      from: () => ({
        select: () => ({ eq: () => ({ data: [], error: null }) }),
        insert: () => ({ data: null, error: null }),
        update: () => ({ eq: () => ({ data: null, error: null }) }),
        delete: () => ({ eq: () => ({ data: null, error: null }) })
      })
    } as any
  }

  // æ£€æŸ¥æ˜¯å¦æ˜¯å ä½ç¬¦é…ç½®
  if (supabaseUrl.includes('placeholder') || supabaseAnonKey === 'placeholder_key') {
    console.warn('Using placeholder Supabase configuration, features will be limited')
    // è¿”å›æ¨¡æ‹Ÿå®¢æˆ·ç«¯
    return {
      auth: {
        getSession: async () => ({ data: { session: null }, error: null }),
        signInWithOAuth: async () => ({ data: null, error: { message: 'Supabase not configured' } }),
        signInWithPassword: async () => ({ data: { user: null, session: null }, error: { message: 'Supabase not configured' } }),
        signUp: async () => ({ data: { user: null, session: null }, error: { message: 'Supabase not configured' } }),
        signOut: async () => ({ error: null }),
        onAuthStateChange: (callback: any) => {
          // ç«‹å³è°ƒç”¨callbackä»¥å®Œæˆåˆå§‹åŒ–
          setTimeout(() => callback('INITIAL_SESSION', null), 0)
          return { data: { subscription: { unsubscribe: () => {} } } }
        }
      },
      from: () => ({
        select: () => ({ eq: () => ({ data: [], error: null }) }),
        insert: () => ({ data: null, error: null }),
        update: () => ({ eq: () => ({ data: null, error: null }) }),
        delete: () => ({ eq: () => ({ data: null, error: null }) })
      })
    } as any
  }

  return createSupabaseClient(supabaseUrl, supabaseAnonKey, {
    auth: {
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: true,
      storageKey: 'sitehub-auth-token',
      storage: typeof window !== 'undefined' ? window.localStorage : undefined,
      flowType: 'pkce'
    }
  })
}
=== /Users/8086k/project/components/lib/utils.ts ===
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
=== /Users/8086k/project/components/lib/webview-utils.ts ===
/**
 * WebViewç¯å¢ƒæ£€æµ‹å’Œé“¾æ¥å¤„ç†å·¥å…·
 * ç”¨äºä¼˜åŒ–åœ¨åŸç”Ÿåº”ç”¨WebViewä¸­çš„ç”¨æˆ·ä½“éªŒ
 */

/**
 * æ£€æµ‹å½“å‰æ˜¯å¦åœ¨WebViewç¯å¢ƒä¸­è¿è¡Œ
 */
export function isWebView(): boolean {
  if (typeof window === 'undefined') {
    return false
  }

  const userAgent = navigator.userAgent || navigator.vendor || (window as any).opera

  // æ£€æµ‹å¸¸è§çš„WebViewæ ‡è¯†
  const webViewIndicators = [
    // Android WebView
    /wv/i,
    /WebView/i,
    // iOS WebView
    /(iPhone|iPod|iPad)(?!.*Safari\/)/i,
    // React Native
    /ReactNativeWebView/i,
    // Electron
    /Electron/i,
    // å¾®ä¿¡å†…ç½®æµè§ˆå™¨
    /MicroMessenger/i,
    // QQå†…ç½®æµè§ˆå™¨
    /QQ\//i,
    // å¾®åšå†…ç½®æµè§ˆå™¨
    /Weibo/i,
  ]

  // æ£€æŸ¥æ˜¯å¦åŒ¹é…ä»»ä½•WebViewæ ‡è¯†
  const isWebViewUA = webViewIndicators.some(regex => regex.test(userAgent))

  // æ£€æŸ¥æ˜¯å¦å­˜åœ¨WebViewç›¸å…³çš„å…¨å±€å¯¹è±¡
  const hasWebViewObject = !!(
    (window as any).ReactNativeWebView ||
    (window as any).webkit?.messageHandlers ||
    (window as any).Android
  )

  // æ£€æµ‹æ˜¯å¦ä¸ºç‹¬ç«‹åº”ç”¨ï¼ˆPWAæˆ–WebViewï¼‰
  const isStandalone =
    (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) ||
    (navigator as any).standalone ||
    document.referrer.includes('android-app://')

  return isWebViewUA || hasWebViewObject || isStandalone
}

/**
 * æ£€æµ‹WebViewçš„å…·ä½“ç±»å‹
 */
export function getWebViewType(): 'android' | 'ios' | 'electron' | 'wechat' | 'tauri' | 'capacitor' | 'median' | 'nativeify' | 'browser' | 'unknown' {
  if (typeof window === 'undefined') {
    return 'unknown'
  }

  const userAgent = navigator.userAgent || ''

  // æ£€æµ‹ median.co (iOS/Android)
  // median.co ä¼šæ³¨å…¥ç‰¹å®šçš„å…¨å±€å¯¹è±¡æˆ– User-Agent æ ‡è¯†
  if ((window as any).median || /median/i.test(userAgent) || /gonative/i.test(userAgent)) {
    return 'median'
  }

  // æ£€æµ‹ nativeify (Electron-based, Mac/Windows/Linux)
  // nativeify åŸºäº Electronï¼Œä½†å¯èƒ½æœ‰è‡ªå®šä¹‰æ ‡è¯†
  if ((window as any).nativeify || (/Electron/i.test(userAgent) && (window as any).process?.versions?.electron)) {
    return 'nativeify'
  }

  // æ£€æµ‹ Tauri
  if ((window as any).__TAURI__) {
    return 'tauri'
  }

  // æ£€æµ‹ Capacitor
  if ((window as any).Capacitor) {
    const platform = (window as any).Capacitor.getPlatform()
    if (platform === 'ios') return 'ios'
    if (platform === 'android') return 'android'
    return 'capacitor'
  }

  if (/MicroMessenger/i.test(userAgent)) {
    return 'wechat'
  }

  if (/Electron/i.test(userAgent)) {
    return 'electron'
  }

  if ((window as any).ReactNativeWebView || /Android/i.test(userAgent)) {
    return 'android'
  }

  if (/(iPhone|iPod|iPad)/i.test(userAgent) && !/(Safari)/i.test(userAgent)) {
    return 'ios'
  }

  if (!isWebView()) {
    return 'browser'
  }

  return 'unknown'
}

/**
 * è·å–è¿è¡Œå¹³å°ï¼ˆç®€åŒ–ç‰ˆï¼‰
 */
export function getPlatform(): 'ios' | 'android' | 'desktop' | 'web' {
  const type = getWebViewType()

  switch (type) {
    case 'ios':
    case 'capacitor':
    case 'median': // median.co æ”¯æŒ iOS/Android
      return getMedianPlatform() // éœ€è¦è¿›ä¸€æ­¥åˆ¤æ–­medianæ˜¯iOSè¿˜æ˜¯Android
    case 'android':
      return 'android'
    case 'tauri':
    case 'electron':
    case 'nativeify': // nativeify æ˜¯æ¡Œé¢ç«¯
      return 'desktop'
    default:
      return 'web'
  }
}

/**
 * åˆ¤æ–­ median.co çš„å…·ä½“å¹³å°
 */
function getMedianPlatform(): 'ios' | 'android' {
  const userAgent = navigator.userAgent || ''
  if (/(iPhone|iPod|iPad)/i.test(userAgent)) {
    return 'ios'
  }
  return 'android'
}

/**
 * åˆ¤æ–­é“¾æ¥æ˜¯å¦ä¸ºå†…éƒ¨é“¾æ¥
 */
export function isInternalLink(url: string): boolean {
  if (!url) return false

  try {
    const link = new URL(url, window.location.origin)
    return link.origin === window.location.origin
  } catch {
    // ç›¸å¯¹è·¯å¾„è§†ä¸ºå†…éƒ¨é“¾æ¥
    return !url.startsWith('http://') && !url.startsWith('https://')
  }
}

/**
 * åˆ¤æ–­é“¾æ¥æ˜¯å¦ä¸ºSiteHubç®¡ç†çš„ç«™ç‚¹é“¾æ¥
 * ï¼ˆå³ç”¨æˆ·æ·»åŠ çš„ç½‘ç«™é“¾æ¥ï¼Œè¿™äº›åº”è¯¥åœ¨æ–°æ ‡ç­¾é¡µæ‰“å¼€ï¼‰
 */
export function isSiteHubManagedLink(element: HTMLElement): boolean {
  // æ£€æŸ¥æ˜¯å¦åœ¨ç½‘ç«™å¡ç‰‡æˆ–ç‰¹å®šç»„ä»¶å†…
  return !!(
    element.closest('[data-site-card]') ||
    element.closest('[data-external-link]') ||
    element.closest('.site-card') ||
    element.classList.contains('external-link')
  )
}

/**
 * åœ¨WebViewä¸­æ‰“å¼€é“¾æ¥çš„ç­–ç•¥
 */
export interface WebViewLinkOptions {
  /**
   * æ˜¯å¦å¼ºåˆ¶åœ¨WebViewå†…éƒ¨æ‰“å¼€
   */
  forceInternal?: boolean

  /**
   * æ˜¯å¦å¼ºåˆ¶åœ¨å¤–éƒ¨æµè§ˆå™¨æ‰“å¼€
   */
  forceExternal?: boolean

  /**
   * è‡ªå®šä¹‰å¤„ç†å‡½æ•°
   */
  customHandler?: (url: string) => void
}

/**
 * âœ… ç»Ÿä¸€çš„é“¾æ¥æ‰“å¼€å‡½æ•°ï¼ˆå¤šç«¯æ”¯æŒï¼‰
 * åœ¨ App å†…æ‰“å¼€é“¾æ¥ï¼Œè€Œä¸æ˜¯è·³è½¬åˆ°å¤–éƒ¨æµè§ˆå™¨
 */
export async function openInWebView(url: string, options: WebViewLinkOptions = {}): Promise<void> {
  const { forceInternal = false, forceExternal = false, customHandler } = options

  // å¦‚æœæœ‰è‡ªå®šä¹‰å¤„ç†å‡½æ•°ï¼Œä¼˜å…ˆä½¿ç”¨
  if (customHandler) {
    customHandler(url)
    return
  }

  const platform = getPlatform()
  const isInternal = isInternalLink(url)

  // å†…éƒ¨é“¾æ¥ç›´æ¥è·³è½¬
  if (isInternal || forceInternal) {
    window.location.href = url
    return
  }

  // å¼ºåˆ¶å¤–éƒ¨æ‰“å¼€
  if (forceExternal) {
    openInExternalBrowser(url, getWebViewType())
    return
  }

  console.log(`[openInWebView] å¹³å°: ${platform}, WebViewç±»å‹: ${getWebViewType()}, URL: ${url}`)

  const webViewType = getWebViewType()

  // æ ¹æ®å¹³å°é€‰æ‹©æ‰“å¼€æ–¹å¼
  switch (platform) {
    case 'ios':
    case 'android':
      // ğŸ¯ median.co (iOS/Android) - åœ¨å½“å‰WebViewæ‰“å¼€ï¼Œä¸è·³å‡ºApp
      if (webViewType === 'median') {
        console.log('[openInWebView] median.co æ£€æµ‹åˆ°ï¼Œåœ¨å½“å‰WebViewæ‰“å¼€')
        // median.co: ç›´æ¥åœ¨å½“å‰çª—å£æ‰“å¼€ï¼Œä¸ä¼šè·³å‡ºApp
        window.location.href = url
        return
      }

      // Capacitor InAppBrowser
      if ((window as any).Capacitor?.Plugins?.Browser) {
        try {
          await (window as any).Capacitor.Plugins.Browser.open({
            url: url,
            presentationStyle: 'fullscreen',
            toolbarColor: '#1e293b'
          })
          console.log('[openInWebView] ä½¿ç”¨ Capacitor Browser æ‰“å¼€')
          return
        } catch (error) {
          console.error('[openInWebView] Capacitor Browser å¤±è´¥:', error)
        }
      }

      // Fallback: å½“å‰çª—å£æ‰“å¼€
      console.log('[openInWebView] ä½¿ç”¨ Fallback: å½“å‰çª—å£æ‰“å¼€')
      window.location.href = url
      break

    case 'desktop':
      // ğŸ¯ nativeify (Mac/Windows/Linux) - åœ¨å½“å‰çª—å£æ‰“å¼€ï¼Œä¸è·³å‡ºApp
      if (webViewType === 'nativeify') {
        console.log('[openInWebView] nativeify æ£€æµ‹åˆ°ï¼Œåœ¨å½“å‰WebViewæ‰“å¼€')
        // nativeify: ç›´æ¥åœ¨å½“å‰çª—å£æ‰“å¼€ï¼Œä¸ä¼šè·³åˆ°ç³»ç»Ÿæµè§ˆå™¨
        window.location.href = url
        return
      }

      // Tauri - ç¨ååœ¨ä¸‹ä¸€ä¸ªä»»åŠ¡ä¸­å®ç°
      if ((window as any).__TAURI__) {
        console.log('[openInWebView] Tauri ç¯å¢ƒæ£€æµ‹åˆ°ï¼Œåœ¨å½“å‰çª—å£æ‰“å¼€')
        // ä¸´æ—¶æ–¹æ¡ˆï¼šåœ¨å½“å‰çª—å£æ‰“å¼€
        // TODO: å®ç° Tauri å¤šçª—å£æ–¹æ¡ˆ
        window.location.href = url
      } else {
        // Electron æˆ–å…¶ä»–æ¡Œé¢ç¯å¢ƒ
        console.log('[openInWebView] Electron/å…¶ä»–æ¡Œé¢ç¯å¢ƒï¼Œåœ¨å½“å‰çª—å£æ‰“å¼€')
        window.location.href = url
      }
      break

    case 'web':
    default:
      // æµè§ˆå™¨ç¯å¢ƒï¼šæ–°æ ‡ç­¾é¡µæ‰“å¼€
      console.log('[openInWebView] æµè§ˆå™¨ç¯å¢ƒï¼Œæ–°æ ‡ç­¾é¡µæ‰“å¼€')
      window.open(url, '_blank', 'noopener,noreferrer')
      break
  }
}

/**
 * åœ¨WebViewç¯å¢ƒä¸­å¤„ç†é“¾æ¥ç‚¹å‡»ï¼ˆæ—§ç‰ˆï¼Œä¿ç•™å‘åå…¼å®¹ï¼‰
 */
export function handleWebViewLink(url: string, options: WebViewLinkOptions = {}): void {
  openInWebView(url, options).catch(error => {
    console.error('[handleWebViewLink] æ‰“å¼€é“¾æ¥å¤±è´¥:', error)
    // Fallback: ä½¿ç”¨ä¼ ç»Ÿæ–¹å¼
    window.location.href = url
  })
}

/**
 * åœ¨å¤–éƒ¨æµè§ˆå™¨ä¸­æ‰“å¼€é“¾æ¥ï¼ˆé’ˆå¯¹WebViewç¯å¢ƒï¼‰
 */
function openInExternalBrowser(url: string, webViewType: ReturnType<typeof getWebViewType>): void {
  // å°è¯•é€šè¿‡WebViewæä¾›çš„æ¥å£æ‰“å¼€å¤–éƒ¨æµè§ˆå™¨

  // React Native WebView
  if ((window as any).ReactNativeWebView) {
    (window as any).ReactNativeWebView.postMessage(JSON.stringify({
      type: 'OPEN_EXTERNAL',
      url: url
    }))
    return
  }

  // iOS WKWebView
  if ((window as any).webkit?.messageHandlers?.openExternal) {
    (window as any).webkit.messageHandlers.openExternal.postMessage({ url })
    return
  }

  // Android WebView
  if ((window as any).Android?.openExternal) {
    (window as any).Android.openExternal(url)
    return
  }

  // å¾®ä¿¡ç¯å¢ƒ
  if (webViewType === 'wechat') {
    // å¾®ä¿¡ä¸­æ— æ³•ç›´æ¥æ‰“å¼€å¤–éƒ¨æµè§ˆå™¨ï¼Œæç¤ºç”¨æˆ·åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€
    alert('è¯·ç‚¹å‡»å³ä¸Šè§’èœå•ï¼Œé€‰æ‹©"åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€"')
    return
  }

  // é»˜è®¤ï¼šåœ¨å½“å‰çª—å£æ‰“å¼€
  window.location.href = url
}

/**
 * ä¸ºæ‰€æœ‰å¤–éƒ¨é“¾æ¥æ·»åŠ WebViewå…¼å®¹å¤„ç†
 * åœ¨åº”ç”¨åˆå§‹åŒ–æ—¶è°ƒç”¨ä¸€æ¬¡
 */
export function setupWebViewLinkHandlers(): void {
  if (typeof window === 'undefined' || !isWebView()) {
    return
  }

  // æ‹¦æˆªæ‰€æœ‰é“¾æ¥ç‚¹å‡»
  document.addEventListener('click', (e) => {
    const target = e.target as HTMLElement
    const link = target.closest('a') as HTMLAnchorElement

    if (!link || !link.href) {
      return
    }

    // æ£€æŸ¥æ˜¯å¦ä¸ºSiteHubç®¡ç†çš„ç«™ç‚¹é“¾æ¥
    if (isSiteHubManagedLink(link)) {
      // è®©ç»„ä»¶è‡ªå·±çš„onClickå¤„ç†
      return
    }

    // æ£€æŸ¥é“¾æ¥æ˜¯å¦æœ‰ç‰¹æ®Šå±æ€§
    const forceInternal = link.hasAttribute('data-webview-internal')
    const forceExternal = link.hasAttribute('data-webview-external')

    // å¦‚æœæ˜¯æ™®é€šçš„å¤–éƒ¨é“¾æ¥ï¼Œåœ¨WebViewä¸­é»˜è®¤å½“å‰çª—å£æ‰“å¼€
    if (!isInternalLink(link.href) && !forceExternal) {
      e.preventDefault()
      handleWebViewLink(link.href, { forceInternal })
    }
  }, true)

  console.log('[WebView] Link handlers initialized for', getWebViewType())
}

/**
 * è·å–WebViewç¯å¢ƒä¿¡æ¯ï¼ˆç”¨äºè°ƒè¯•ï¼‰
 */
export function getWebViewInfo() {
  return {
    isWebView: isWebView(),
    type: getWebViewType(),
    userAgent: navigator.userAgent,
    standalone: (navigator as any).standalone,
    displayMode: window.matchMedia('(display-mode: standalone)').matches ? 'standalone' : 'browser',
  }
}
=== /Users/8086k/project/components/lib/wechat-auth.ts ===
// @ts-ignore
import OAuth from 'wechat-oauth'
import { supabase } from './supabase'

interface WeChatTokenResult {
  data: {
    access_token: string
    openid: string
    refresh_token: string
    scope: string
    unionid?: string
  }
}

interface WeChatUserInfo {
  openid: string
  nickname: string
  sex: number
  province: string
  city: string
  country: string
  headimgurl: string
  privilege: string[]
  unionid?: string
}

// Initialize WeChat OAuth client
const client = new OAuth(
  process.env.NEXT_PUBLIC_WECHAT_APP_ID!,
  process.env.WECHAT_APP_SECRET!
)

export const wechatAuth = {
  getAuthUrl: () => {
    const state = Math.random().toString(36).substring(7)
    return client.getAuthorizeURL(
      `${process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3000'}/api/auth/wechat/callback`,
      state,
      'snsapi_userinfo'
    )
  },

  getAccessToken: (code: string): Promise<WeChatTokenResult> => {
    return new Promise((resolve, reject) => {
      client.getAccessToken(code, (err: any, result: WeChatTokenResult) => {
        if (err) reject(err)
        else resolve(result)
      })
    })
  },

  getUserInfo: (openid: string, accessToken: string): Promise<WeChatUserInfo> => {
    return new Promise((resolve, reject) => {
      client.getUser(openid, accessToken, (err: any, result: WeChatUserInfo) => {
        if (err) reject(err)
        else resolve(result)
      })
    })
  },

  // New method to handle WeChat user authentication with Supabase
  authenticateUser: async (userInfo: WeChatUserInfo) => {
    try {
      // First, try to find existing user by WeChat openid
      const { data: existingUser, error: fetchError } = await supabase
        .from('profiles')
        .select('*')
        .eq('wechat_openid', userInfo.openid)
        .single()

      if (existingUser) {
        // User exists, create a session
        const { data: sessionData, error: sessionError } = await supabase.auth.signInWithPassword({
          email: existingUser.email,
          password: 'wechat_user_' + userInfo.openid // This should be handled differently in production
        })
        
        if (sessionError) {
          throw sessionError
        }
        
        return { user: existingUser, isNew: false }
      } else {
        // Create new user
        const email = `${userInfo.openid}@wechat.local`
        const password = 'wechat_user_' + userInfo.openid + '_' + Math.random().toString(36).substring(7)
        
        const { data: authData, error: authError } = await supabase.auth.signUp({
          email,
          password,
          options: {
            data: {
              provider: 'wechat',
              wechat_openid: userInfo.openid,
              wechat_unionid: userInfo.unionid,
              nickname: userInfo.nickname,
              avatar_url: userInfo.headimgurl,
              full_name: userInfo.nickname,
              city: userInfo.city,
              province: userInfo.province,
              country: userInfo.country
            }
          }
        })

        if (authError) {
          throw authError
        }

        return { user: authData.user, isNew: true }
      }
    } catch (error) {
      console.error('WeChat authentication error:', error)
      throw error
    }
  }
} === /Users/8086k/project/components/next-env.d.ts ===
/// <reference types="next" />
/// <reference types="next/image-types/global" />
/// <reference types="next/navigation-types/compat/navigation" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.
=== /Users/8086k/project/components/pages/api/auth-cn.ts ===
import type { NextApiRequest, NextApiResponse } from 'next'
import cloudbase from '@cloudbase/node-sdk'
import bcrypt from 'bcryptjs'
import * as jwt from 'jsonwebtoken'

/**
 * å›½å†…ç”¨æˆ·é‚®ç®±æ³¨å†Œ/ç™»å½• API
 * ä½¿ç”¨è…¾è®¯äº‘ CloudBase Node.js SDK æ•°æ®åº“é›†åˆ
 * 
 * ä¸ app/api/auth/email/route.ts ä¸­çš„é€»è¾‘ä¸€è‡´ï¼Œ
 * ä½†è¿™æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„ API æ¥å£ï¼Œä¸“é—¨ç”¨äºå›½å†…ç”¨æˆ·è®¤è¯æµ‹è¯•
 */
export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  // âœ… è¯Šæ–­æ—¥å¿— 1: æ‰“å°å®Œæ•´è¯·æ±‚ä½“
  console.log("âœ… [API Received]: ", JSON.stringify(req.body, null, 2))
  
  // åªæ¥å— POST è¯·æ±‚
  if (req.method !== 'POST') {
    return res.status(405).json({ 
      success: false, 
      message: 'Method not allowed' 
    })
  }

  try {
    const { email, password, action = 'signup' } = req.body
    
    // âœ… è¯Šæ–­æ—¥å¿— 2: æ‰“å°æå–çš„ email å’Œ action
    console.log(`âœ… [Action]: ${action}, [Email to Check]: ${email}`)

    // éªŒè¯è¯·æ±‚å‚æ•°
    if (!email || !password) {
      return res.status(400).json({
        success: false,
        message: 'è¯·æä¾›é‚®ç®±å’Œå¯†ç '
      })
    }

    // éªŒè¯å¯†ç é•¿åº¦
    if (password.length < 6) {
      return res.status(400).json({
        success: false,
        message: 'å¯†ç è‡³å°‘éœ€è¦6ä½'
      })
    }

    // åˆå§‹åŒ– CloudBase App å®ä¾‹
    const app = cloudbase.init({
      env: process.env.TENCENT_ENV_ID || process.env.NEXT_PUBLIC_WECHAT_CLOUDBASE_ID,
      secretId: process.env.TENCENT_SECRET_ID || process.env.CLOUDBASE_SECRET_ID,
      secretKey: process.env.TENCENT_SECRET_KEY || process.env.CLOUDBASE_SECRET_KEY
    })

    const db = app.database()
    const usersCollection = db.collection('web_users')

    if (action === 'signup') {
      // æ³¨å†Œé€»è¾‘
      try {
        // âœ… è¯Šæ–­æ—¥å¿— 3: åœ¨æ•°æ®åº“æŸ¥è¯¢ä¹‹å‰æ‰“å°å³å°†æŸ¥è¯¢çš„ email
        console.log(`ğŸ” [Querying Database For]: ${email}`)
        
        // å…ˆæ£€æŸ¥é‚®ç®±æ˜¯å¦å·²å­˜åœ¨
        const existingUserResult = await usersCollection.where({ email }).get()
        console.log(`ğŸ” [Existing User Check]: Found ${existingUserResult.data?.length || 0} user(s)`)
        
        if (existingUserResult.data && existingUserResult.data.length > 0) {
          console.log(`âš ï¸ [Email Already Exists]: ${email}`)
          return res.status(400).json({
            success: false,
            message: 'è¯¥é‚®ç®±å·²è¢«æ³¨å†Œ'
          })
        }
        
        // åŠ å¯†å¯†ç 
        const hashedPassword = await bcrypt.hash(password, 10)

        // åˆ›å»ºæ–°ç”¨æˆ·
        const newUser = {
          email: email,
          password: hashedPassword,
          name: email.includes('@') ? email.split('@')[0] : email,
          pro: false,
          region: 'china',
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        }

        console.log('âœ… [Creating User]:', JSON.stringify(newUser, null, 2))
        const result = await usersCollection.add(newUser)
        console.log(`âœ… [User Created Successfully]: ID=${result.id}, Email=${email}`)

        // ç”Ÿæˆ JWT Tokenï¼ˆæ³¨å†ŒæˆåŠŸåè‡ªåŠ¨ç™»å½•ï¼‰
        // æ³¨æ„ï¼šCloudBase add() è¿”å›çš„ result.id å°±æ˜¯æ–‡æ¡£çš„ _id
        const tokenPayload = {
          userId: result.id, // CloudBase add() è¿”å›çš„ id å°±æ˜¯ _id
          email: email,
          region: 'china'
        }

        // âœ… åŠ¨æ€è®¾ç½® Token æœ‰æ•ˆæœŸï¼šæ™®é€šç”¨æˆ· 30 å¤©ï¼Œé«˜çº§ä¼šå‘˜ 90 å¤©ï¼ˆå¤šç«¯æŒä¹…åŒ–ä¼˜åŒ–ï¼‰
        const expiresIn = newUser.pro ? '90d' : '30d'

        const token = jwt.sign(
          tokenPayload,
          process.env.JWT_SECRET || 'fallback-secret-key-for-development-only',
          { expiresIn: expiresIn }
        )

        console.log(`âœ… [JWT Token Generated]: For new user ${email}`)

        return res.status(200).json({
          success: true,
          message: 'æ³¨å†ŒæˆåŠŸ',
          user: {
            id: result.id, // è¿”å›ç»™å‰ç«¯çš„ç”¨æˆ·ID
            userId: result.id, // ç¡®ä¿userIdå­—æ®µä¹Ÿå­˜åœ¨
            email,
            name: newUser.name,
            pro: false,
            region: 'china'
          },
          token: token // è¿”å› JWT Tokenï¼Œè®©ç”¨æˆ·æ³¨å†Œåè‡ªåŠ¨ç™»å½•
        })
      } catch (error: any) {
        console.error('æ³¨å†Œé”™è¯¯:', error)
        console.error('é”™è¯¯è¯¦æƒ…:', JSON.stringify(error, null, 2))
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯é‚®ç®±å·²å­˜åœ¨çš„é”™è¯¯
        if (error.message && (
          error.message.includes('duplicate') || 
          error.message.includes('E11000') ||
          error.message.includes('å·²å­˜åœ¨')
        )) {
          return res.status(400).json({
            success: false,
            message: 'è¯¥é‚®ç®±å·²è¢«æ³¨å†Œ'
          })
        }
        
        return res.status(400).json({
          success: false,
          message: error.message || 'æ³¨å†Œå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•'
        })
      }
    } else if (action === 'login') {
      // ç™»å½•é€»è¾‘
      try {
        // âœ… è¯Šæ–­æ—¥å¿—: åœ¨ç™»å½•æŸ¥è¯¢ä¹‹å‰æ‰“å°å³å°†æŸ¥è¯¢çš„ email
        console.log(`ğŸ” [Login - Querying Database For]: ${email}`)
        
        // æŸ¥æ‰¾ç”¨æˆ·
        const userResult = await usersCollection.where({ email }).get()
        console.log(`ğŸ” [Login - Found]: ${userResult.data?.length || 0} user(s)`)

        if (!userResult.data || userResult.data.length === 0) {
          return res.status(400).json({
            success: false,
            message: 'ç”¨æˆ·ä¸å­˜åœ¨æˆ–å¯†ç é”™è¯¯'
          })
        }

        const user = userResult.data[0]

        // éªŒè¯å¯†ç 
        // ğŸ¤« è¯Šæ–­æ—¥å¿—ï¼šæ‰“å°è¦æ¯”è¾ƒçš„å¯†ç ä¿¡æ¯
        console.log(`ğŸ¤« [Password to Compare]: Plain text from user -> ${password}`)
        console.log(`ğŸ¤« [Password to Compare]: Hash from DB -> ${user.password}`)
        
        const isPasswordValid = await bcrypt.compare(password, user.password)
        
        // ğŸ¤” è¯Šæ–­æ—¥å¿—ï¼šæ‰“å° bcrypt.compare çš„ç»“æœ
        console.log(`ğŸ¤” [bcrypt.compare Result]: ${isPasswordValid}`)
        
        if (!isPasswordValid) {
          console.log(`âŒ [Login Failed]: Password mismatch for email ${email}`)
          return res.status(400).json({
            success: false,
            message: 'ç”¨æˆ·ä¸å­˜åœ¨æˆ–å¯†ç é”™è¯¯'
          })
        }
        
        console.log(`âœ… [Login Success]: User ${email} logged in successfully`)

        // ç”Ÿæˆ JWT Token
        const tokenPayload = {
          userId: user._id,
          email: user.email,
          region: 'china'
        }

        // âœ… åŠ¨æ€è®¾ç½® Token æœ‰æ•ˆæœŸï¼šæ™®é€šç”¨æˆ· 30 å¤©ï¼Œé«˜çº§ä¼šå‘˜ 90 å¤©ï¼ˆå¤šç«¯æŒä¹…åŒ–ä¼˜åŒ–ï¼‰
        const expiresIn = user.pro ? '90d' : '30d'

        const token = jwt.sign(
          tokenPayload,
          process.env.JWT_SECRET || 'fallback-secret-key-for-development-only',
          { expiresIn: expiresIn }
        )

        console.log(`âœ… [JWT Token Generated]: For user ${email}`)

        return res.status(200).json({
          success: true,
          message: 'ç™»å½•æˆåŠŸ',
          user: {
            id: user._id, // è¿”å›ç»™å‰ç«¯çš„ç”¨æˆ·ID
            userId: user._id, // ç¡®ä¿userIdå­—æ®µä¹Ÿå­˜åœ¨ï¼ˆä¸JWT tokenä¸­çš„userIdä¸€è‡´ï¼‰
            email: user.email,
            name: user.name,
            pro: user.pro || false,
            region: 'china'
          },
          token: token // è¿”å› JWT Token
        })
      } catch (error: any) {
        console.error('ç™»å½•é”™è¯¯:', error)
        return res.status(400).json({
          success: false,
          message: error.message || 'é‚®ç®±æˆ–å¯†ç é”™è¯¯'
        })
      }
    } else if (action === 'refresh') {
      // âœ… Tokenåˆ·æ–°é€»è¾‘
      try {
        const { userId } = req.body

        if (!userId) {
          return res.status(400).json({
            success: false,
            message: 'ç¼ºå°‘ userId å‚æ•°'
          })
        }

        console.log(`ğŸ”„ [Token Refresh]: å¼€å§‹åˆ·æ–°ç”¨æˆ· ${userId} çš„Token`)

        // ä»CloudBaseè·å–ç”¨æˆ·ä¿¡æ¯
        const cloudbaseDB = cloudbaseApp.database()
        const userResult = await cloudbaseDB
          .collection('web_users')
          .doc(userId)
          .get()

        if (!userResult.data || userResult.data.length === 0) {
          return res.status(404).json({
            success: false,
            message: 'ç”¨æˆ·ä¸å­˜åœ¨'
          })
        }

        const user = userResult.data[0]

        // ç”Ÿæˆæ–°çš„JWT Token
        const tokenPayload = {
          userId: user._id,
          email: user.email,
          region: 'china'
        }

        // âœ… æ ¹æ®ç”¨æˆ·ä¼šå‘˜çŠ¶æ€è®¾ç½®æœ‰æ•ˆæœŸ
        const expiresIn = user.pro ? '90d' : '30d'

        const newToken = jwt.sign(
          tokenPayload,
          process.env.JWT_SECRET || 'fallback-secret-key-for-development-only',
          { expiresIn: expiresIn }
        )

        console.log(`âœ… [Token Refreshed]: For user ${user.email}, expires in ${expiresIn}`)

        return res.status(200).json({
          success: true,
          message: 'Tokenåˆ·æ–°æˆåŠŸ',
          token: newToken,
          expiresIn: expiresIn
        })
      } catch (error: any) {
        console.error('Tokenåˆ·æ–°é”™è¯¯:', error)
        return res.status(400).json({
          success: false,
          message: error.message || 'Tokenåˆ·æ–°å¤±è´¥'
        })
      }
    } else {
      return res.status(400).json({
        success: false,
        message: 'æ— æ•ˆçš„ action å‚æ•°ï¼Œè¯·ä½¿ç”¨ signup, login æˆ– refresh'
      })
    }

  } catch (error: any) {
    console.error('API é”™è¯¯:', error)
    return res.status(500).json({
      success: false,
      message: error.message || 'æœåŠ¡å™¨é”™è¯¯'
    })
  }
}

=== /Users/8086k/project/components/pages/api/custom-sites-cn.ts ===
import type { NextApiRequest, NextApiResponse } from 'next'
import cloudbase from '@cloudbase/node-sdk'
import jwt from 'jsonwebtoken'

/**
 * å›½å†…ç”¨æˆ·è‡ªå®šä¹‰ç½‘ç«™ API
 * ä½¿ç”¨è…¾è®¯äº‘ CloudBase æ•°æ®åº“
 * Collection: web_custom_sites
 */

function verifyToken(token: string): any {
  try {
    return jwt.verify(token, process.env.JWT_SECRET || 'fallback-secret-key-for-development-only')
  } catch (error) {
    console.error('âŒ [Custom-Sites-CN] TokenéªŒè¯å¤±è´¥:', error)
    return null
  }
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  // éªŒè¯JWT Token
  const authHeader = req.headers.authorization
  if (!authHeader?.startsWith('Bearer ')) {
    return res.status(401).json({ success: false, message: 'æœªæˆæƒ' })
  }

  const token = authHeader.substring(7)
  const decoded = verifyToken(token)

  console.log('ğŸ” [Custom-Sites-CN] Token decoded:', decoded)

  if (!decoded?.userId) {
    console.error('âŒ [Custom-Sites-CN] Tokenæ— æ•ˆæˆ–ç¼ºå°‘userId')
    return res.status(401).json({ success: false, message: 'Tokenæ— æ•ˆ' })
  }

  const userId = decoded.userId
  console.log('âœ… [Custom-Sites-CN] Using userId from token:', userId)

  // åˆå§‹åŒ– CloudBase
  const app = cloudbase.init({
    env: process.env.NEXT_PUBLIC_WECHAT_CLOUDBASE_ID!,
    secretId: process.env.CLOUDBASE_SECRET_ID!,
    secretKey: process.env.CLOUDBASE_SECRET_KEY!
  })

  const db = app.database()
  const collection = db.collection('web_custom_sites')

  try {
    // GET: è·å–è‡ªå®šä¹‰ç½‘ç«™åˆ—è¡¨
    if (req.method === 'GET') {
      console.log('ğŸ“– [Custom-Sites-CN GET] Querying custom sites for userId:', userId)
      const result = await collection
        .where({ user_id: userId })
        .orderBy('created_at', 'desc')
        .get()

      console.log(`âœ… [Custom-Sites-CN GET] Found ${result.data?.length || 0} custom sites`)
      console.log('ğŸ“Š [Custom-Sites-CN GET] Data:', JSON.stringify(result.data, null, 2))

      return res.status(200).json({
        success: true,
        sites: result.data || []
      })
    }

    // POST: æ·»åŠ è‡ªå®šä¹‰ç½‘ç«™
    if (req.method === 'POST') {
      const { name, url, logo, category, description } = req.body

      if (!name || !url) {
        return res.status(400).json({ success: false, message: 'ç¼ºå°‘nameæˆ–url' })
      }

      console.log('â• [Custom-Sites-CN POST] Adding custom site:', { userId, name, url })

      const addResult = await collection.add({
        user_id: userId,
        name,
        url,
        logo: logo || '',
        category: category || 'custom',
        description: description || '',
        created_at: new Date(),
        updated_at: new Date()
      })

      console.log('âœ… [Custom-Sites-CN POST] Custom site added successfully:', addResult)

      return res.status(200).json({
        success: true,
        site: {
          id: addResult.id,
          user_id: userId,
          name,
          url,
          logo,
          category,
          description
        }
      })
    }

    // DELETE: åˆ é™¤è‡ªå®šä¹‰ç½‘ç«™
    if (req.method === 'DELETE') {
      const { siteId } = req.body

      if (!siteId) {
        return res.status(400).json({ success: false, message: 'ç¼ºå°‘siteId' })
      }

      console.log('ğŸ—‘ï¸ [Custom-Sites-CN DELETE] Deleting custom site:', { userId, siteId })

      // å…ˆéªŒè¯è¿™ä¸ªç½‘ç«™æ˜¯å¦å±äºå½“å‰ç”¨æˆ·
      const checkResult = await collection
        .where({
          _id: siteId,
          user_id: userId
        })
        .get()

      if (!checkResult.data || checkResult.data.length === 0) {
        return res.status(404).json({ success: false, message: 'ç½‘ç«™ä¸å­˜åœ¨æˆ–æ— æƒåˆ é™¤' })
      }

      await collection.doc(siteId).remove()

      console.log('âœ… [Custom-Sites-CN DELETE] Custom site deleted successfully')

      return res.status(200).json({ success: true })
    }

    // ä¸æ”¯æŒçš„æ–¹æ³•
    return res.status(405).json({ success: false, message: 'æ–¹æ³•ä¸æ”¯æŒ' })

  } catch (error: any) {
    console.error('âŒ [Custom-Sites-CN] Error:', error)
    return res.status(500).json({
      success: false,
      message: error.message || 'æœåŠ¡å™¨é”™è¯¯'
    })
  }
}
=== /Users/8086k/project/components/pages/api/favorites-cn.ts ===
import type { NextApiRequest, NextApiResponse } from 'next'
import cloudbase from '@cloudbase/node-sdk'
import jwt from 'jsonwebtoken'

/**
 * å›½å†…ç”¨æˆ·æ”¶è—åŠŸèƒ½ APIï¼ˆä½¿ç”¨å·²æœ‰ä¾èµ–ï¼Œä¸å¼•å…¥æ–°åŒ…ï¼‰
 */

function verifyToken(token: string): any {
  try {
    return jwt.verify(token, process.env.JWT_SECRET || 'fallback-secret-key-for-development-only')
  } catch (error) {
    return null
  }
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    const authHeader = req.headers.authorization
    if (!authHeader?.startsWith('Bearer ')) {
      return res.status(401).json({ success: false, message: 'æœªæˆæƒ' })
    }

    const token = authHeader.substring(7)
    const decoded = verifyToken(token)

    console.log('ğŸ” [Favorites-CN] Token decoded:', decoded)

    if (!decoded?.userId) {
      console.error('âŒ [Favorites-CN] Tokenæ— æ•ˆæˆ–ç¼ºå°‘userId')
      return res.status(401).json({ success: false, message: 'Tokenæ— æ•ˆ' })
    }

    const userId = decoded.userId
    console.log('âœ… [Favorites-CN] Using userId from token:', userId)

    // åˆå§‹åŒ– CloudBaseï¼ˆä½¿ç”¨å·²æœ‰ä¾èµ–ï¼‰
    const app = cloudbase.init({
      env: process.env.NEXT_PUBLIC_WECHAT_CLOUDBASE_ID!,
      secretId: process.env.CLOUDBASE_SECRET_ID!,
      secretKey: process.env.CLOUDBASE_SECRET_KEY!
    })

    const db = app.database()
    const collection = db.collection('web_favorites')

    // GET: è·å–æ”¶è—åˆ—è¡¨
    if (req.method === 'GET') {
      console.log('ğŸ“– [Favorites-CN GET] Querying favorites for userId:', userId)
      const result = await collection.where({ user_id: userId }).get()
      console.log(`âœ… [Favorites-CN GET] Found ${result.data?.length || 0} favorites`)
      console.log('ğŸ“Š [Favorites-CN GET] Data:', JSON.stringify(result.data, null, 2))
      return res.status(200).json({
        success: true,
        favorites: result.data.map((f: any) => f.site_id)
      })
    }

    // POST: æ·»åŠ æ”¶è—
    if (req.method === 'POST') {
      const { siteId } = req.body
      if (!siteId) {
        return res.status(400).json({ success: false, message: 'ç¼ºå°‘siteId' })
      }

      console.log('â• [Favorites-CN POST] Adding favorite:', { userId, siteId })
      const addResult = await collection.add({
        user_id: userId,
        site_id: siteId,
        created_at: new Date()
      })
      console.log('âœ… [Favorites-CN POST] Favorite added successfully:', addResult)

      return res.status(200).json({ success: true })
    }

    // DELETE: åˆ é™¤æ”¶è—
    if (req.method === 'DELETE') {
      const { siteId } = req.body
      if (!siteId) {
        return res.status(400).json({ success: false, message: 'ç¼ºå°‘siteId' })
      }

      await collection.where({ user_id: userId, site_id: siteId }).remove()
      return res.status(200).json({ success: true })
    }

    return res.status(405).json({ success: false, message: 'Method not allowed' })
  } catch (error: any) {
    console.error('APIé”™è¯¯:', error)
    return res.status(500).json({ success: false, message: error.message })
  }
}
=== /Users/8086k/project/components/tailwind.config.ts ===
import type { Config } from "tailwindcss";

// all in fixtures is set to tailwind v3 as interims solutions

const config: Config = {
    darkMode: ["class"],
    content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
    "*.{js,ts,jsx,tsx,mdx}"
  ],
  theme: {
  	extend: {
  		colors: {
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			},
  			sidebar: {
  				DEFAULT: 'hsl(var(--sidebar-background))',
  				foreground: 'hsl(var(--sidebar-foreground))',
  				primary: 'hsl(var(--sidebar-primary))',
  				'primary-foreground': 'hsl(var(--sidebar-primary-foreground))',
  				accent: 'hsl(var(--sidebar-accent))',
  				'accent-foreground': 'hsl(var(--sidebar-accent-foreground))',
  				border: 'hsl(var(--sidebar-border))',
  				ring: 'hsl(var(--sidebar-ring))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		},
  		keyframes: {
  			'accordion-down': {
  				from: {
  					height: '0'
  				},
  				to: {
  					height: 'var(--radix-accordion-content-height)'
  				}
  			},
  			'accordion-up': {
  				from: {
  					height: 'var(--radix-accordion-content-height)'
  				},
  				to: {
  					height: '0'
  				}
  			}
  		},
  		animation: {
  			'accordion-down': 'accordion-down 0.2s ease-out',
  			'accordion-up': 'accordion-up 0.2s ease-out'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
};
export default config;
